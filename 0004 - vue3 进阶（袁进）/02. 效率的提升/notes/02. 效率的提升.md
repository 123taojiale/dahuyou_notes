## 02. 效率的提升 {ignore}

[toc]

### 前言

- 时长：23min

vue3 和 vue2 对比，效率有很大的提升。官方说：
- vue3 的客户端渲染效率比 vue2 提升了 1.3~2 倍；
- vue3 的 SSR 渲染效率比 vue2 提升了 2~3 倍；

为什么会有这么明显的提升，就是我们后边所需要学习的重点。面试题也可能会问：**vue3 的效率提升主要表现在哪些方面？**

> vue3 几乎已经把效率优化给做到极致了，如果用 vue3 和 react 去比，那 react 远不及 vue3。react 中的一些优化，需要我们手动去配，比较麻烦。
> 下面要介绍的这些点，我们平时在写代码的时候是感知不到的，得去瞅瞅它的源码。所以，现阶段，对于这些内部原理，先有个简单的了解即可，至于是如何实现的，后边有能力了去瞅瞅 vue3 的源码，自然就知道了。

### 静态提升

静态提升包含：
- 提升**静态节点**：没有绑定动态内容的元素节点；
- 提升**静态属性**：写死的属性；

- [x] 静态节点提升

```html
<h1>Hello World</h1>
```

```js
// vue2 对静态节点的处理
render(){
  createVNode("h1", null, "Hello World")
  // ...
}
```

```js
// vue3 对静态节点的处理
const hoisted = createVNode("h1", null, "Hello World")
function render(){
  // 直接使用 hoisted 即可
}
```

- [x] 静态属性提升

```html
<!-- 静态属性 -->
<div class="user">
  {{user.name}}
</div>
```

```js
// vue2 对静态属性的处理
render(){
  createVNode("div", { class: 'user' }, user.name)
  // ...
}
```

```js
// vue3 对静态属性的处理
const hoisted = { class: "user" };

function render(){
  createVNode("div", hoisted, user.name)
  // ...
}
```

虽然该 div 的内容不是静态的，但是它的属性 user 是写死的，是不会发生变化的，所以可以提升该静态属性。

[我的理解] 在学习过 vue2 过后，我们了解到页面中的元素都是通过 render 函数渲染出来的。在调用 render 函数的时候，我们需要将标签名，标签属性，标签内容依次作为参数传递给 render 函数，这些参数都是创建一个元素所必要的一些信息。而 render 函数是在模板预编译阶段结束后生成的，每次我们改动代码，都要重新编译，vue2 在重新编译时，无论是静态的还是动态的，都是统一处理，但是 vue3 对静态的内容做了优化处理，因为静态的内容是死的，不会变，所以它只会处理一次，后续就直接使用之前的结果，不会再进行处理，这样就优化了性能。

### 预字符串化

```html
<!-- xxx 组件模板 -->
<div class="menu-bar-container">
  <div class="logo">
    <h1>logo</h1>
  </div>
  <ul class="nav">
    <li><a href="">menu</a></li>
    <li><a href="">menu</a></li>
    <li><a href="">menu</a></li>
    <li><a href="">menu</a></li>
    <li><a href="">menu</a></li>
  </ul>
  <div class="user">
    <span>{{ user.name }}</span>
  </div>
</div>
```

```js
// vue2 对于连续静态内容的处理方式
const vnode = {
  type: 'div',
  props: {
    class: 'menu-bar-container',
  },
  children: ...
}
... // 挨个创建 vnode
// vue2 中，对于动态内容和静态内容处理的方式都是一样的，都会转为 vnode。
```

![20211030211004](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211030211004.png)

```js
// vue3 对于连续静态内容的处理方式
const _hoisted_2 = _createStaticVNode("<div class=\"logo\"><h1>logo</h1></div><ul class=\"nav\"><li><a href=\"\">menu</a></li><li><a href=\"\">menu</a></li><li><a href=\"\">menu</a></li><li><a href=\"\">menu</a></li><li><a href=\"\">menu</a></li></ul>")
```

![20211030211025](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211030211025.png)

vue3 做的这一优化，在 vue ssr 里边，效率提升特别明显。

[我的理解] 在一个组件中，**动静比**（动态内容/静态内容）往往是很小的，通常占大多数的都是静态内容，动态部分往往不会很多。**在 vue3 中，当编译器遇到大量连续的静态内容，会直接将其编译为一个普通字符串节点**。但是，在 vue2 中，它的处理方式就是将其挨个转换为虚拟节点，虚拟节点就是一个普通的 js 对象，相对于挨个去创建对象，将其直接转为一个普通的字符串节点，后者要高效得多。

> 大量连续的静态节点，具体是多少个呢？
> 目前是 >20 个连续的静态节点。

### 缓存事件处理函数

```html
<button @click="count++">plus</button>
```

```js
// vue2 对绑定到元素身上的事件处理函数的处理方式
render(ctx){
  return createVNode("button", {
    onClick: function($event){
      ctx.count++;
    }
  })
}
```

```js
// vue3 对绑定到元素身上的事件处理函数的处理方式
render(ctx, _cache){
  return createVNode("button", {
    onClick: cache[0] || (cache[0] = ($event) => (ctx.count++))
  })
}
```

[我的理解] 我们知道，事件处理函数的代码其实都是写死的，咋们多次触发同一个事件处理函数，它的业务逻辑都是一样的，并不会发生变化。所以，我们在给元素绑定事件处理函数时，可以将事件处理函数的代码给缓存起来，若开发者没有去改动这块逻辑，那么下次预编译的时候，就可以直接使用上一次缓存的值，而不用再去编译这块代码，从而实现了效率的提升。

### Block Tree

```html
<form>
  <div>
    <label>账号：</label>
    <input v-model="user.loginId" />
  </div>
  <div>
    <label>密码：</label>
    <input v-model="user.loginPwd" />
  </div>
</form>
```

vue2 在对比新旧树的时候，并**不知道哪些节点是静态的，哪些是动态的**，因此只能一层一层比较（patch 阶段），这就浪费了大部分时间在比对静态节点上。

![20211030214627](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211030214627.png)

但是 vue3 依托它强大的编译器，可以标记出哪些节点是静态的，哪些节点是动态的，对于静态节点，它显然是不可能变化的，我们只需要比较动态节点即可。这样就节省了花费在比对静态节点的时间。

![20211030214643](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211030214643.png)

根节点的 vnode 中，会记录该节点下的所有子节点中，那些动态的子节点，这些子节点会存放到一个数组中，只需要遍历该数组，对比数组中的每一项成员即可。这样就不需要去遍历整棵树了。

> eg：
> 左block：[input1, input2]
> 右block：[input1, input2]
> PS：对于这里边的一些细节问题，这里就先不去深究了，比如树不稳定的问题，等等。

### PatchFlag

vue2 在对比每一个节点时，并不知道这个节点哪些相关信息会发生变化，因此只能将所有信息依次比对。

```html
<div class="user" data-id="1" title="user name">
  {{user.name}}
</div>
```

![20211030214747](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211030214747.png)

Block Tree 和 PatchFlag：
- Block Tree：对不需要进行比对的节点进行了优化，只比对动态的节点；（标记出动态节点）
- PatchFlag：对单个节点的比对进行了优化，仅比对可能会发生变化的字段；（标记出动态节点的哪一部分是动态的）