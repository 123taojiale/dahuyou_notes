## 03. API和数据响应式的变化 {ignore}

[toc]

### 前言

- 时长：22min

思考两道面试题：
- 面试题1：为什么 vue3 中去掉了 vue 构造函数？
- **面试题2：谈谈你对 vue3 数据响应式的理解**。（面试中经常问）

### 去掉了 Vue 构造函数

在过去，如果遇到一个页面有多个 `vue` 应用时，往往会遇到一些问题。

```html
<!-- vue2 -->
<div id="app1"></div>
<div id="app2"></div>
<script>
  Vue.use(...); // 此代码会影响所有的vue应用
  Vue.mixin(...); // 此代码会影响所有的vue应用
  Vue.component(...); // 此代码会影响所有的vue应用

	new Vue({
    // 配置
  }).$mount("#app1")

  new Vue({
    // 配置
  }).$mount("#app2")
</script>
```

在 `vue3` 中，去掉了 `Vue` 构造函数，转而使用 `createApp` 创建 `vue` 应用。

```html
<!-- vue3 -->
<div id="app1"></div>
<div id="app2"></div>
<script>
  createApp(根组件).use(...).mixin(...).component(...).mount("#app1")
  createApp(根组件).mount("#app2")
</script>
```

> 更多 vue 应用的 api：[Application API](https://v3.vuejs.org/api/application-api.html)

- [ ] 面试题1：为什么 vue3 中去掉了 vue 构造函数？

vue2 的全局构造函数带来了诸多问题：
1. 调用构造函数的静态方法会对所有 vue 应用生效，不利于隔离不同应用。
2. vue2 的构造函数集成了太多功能，不利于 tree shaking，vue3 把这些功能使用普通函数导出，能够充分利用 tree shaking 优化打包体积。
3. vue2 没有把组件实例和 vue 应用两个概念区分开，在 vue2 中，通过 new Vue 创建的对象，既是一个 vue 应用，同时又是一个特殊的 vue 组件。vue3 中，把两个概念区别开来，通过 createApp 创建的对象，是一个 vue 应用，它内部提供的方法是针对整个应用的，而不再是一个特殊的组件。

> 这道面试题考察的点，偏向于设计理念方面，考察的有点偏，但是也有可能会问，所以还是得了解一些。

参考资料：
- [tree shaking 的含义及其工作原理](https://segmentfault.com/a/1190000038962700)

### 组件实例中的API

```js
// 这里所说的组件实例，其实就是在 vue3 中使用过去 vue2 那样的配置式写法时的 this。
export default {
  data() {
    return {
      // ...
    }
  },
  methods: {
    methodA() {
      this.xxx // => this 指向的就是组件实例
    }
  }
}
```

在 `vue3` 中，组件实例是一个 `Proxy`，它仅提供了下列成员，功能和 `vue2` 一样。
- 属性：[Instance Properties](https://v3.vuejs.org/api/instance-properties.html)
- 方法：[Instance Methods](https://v3.vuejs.org/api/instance-methods.html)

组件实例中的成员，我们可以查阅文档去了解。

### 对比数据响应式

vue2 和 vue3 均在相同的生命周期完成数据响应式，但做法不一样。

![20211031084624](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211031084624.png)

- 在 vue2 中，数据响应式失效的问题。

由于 vue2 在一开始就递归遍历了所有的属性，让这些属性实现数据响应式的效果。这就导致了一个问题：若我们后边又新增了属性，那么新增的属性就不再具备属性响应式的效果了，因为它是后边才添加的，并没有被遍历过。这时若我们还想让该属性也具备数据响应式，那么就得调用 `this.$set` 这个 api 来实现。但是 vue3 中是使用 proxy，它代理的是整个对象，是动态的，所以同样的场景，若出现在 vue3 中，新增的属性依旧具备数据响应式的效果。因此，在 vue3 中，我们会发现原先的 `this.$set` 这个 api，已经被移除掉了。

- [ ] 面试题2：谈谈你对 vue3 数据响应式的理解。

需要了解以下几点：
- vue3 不再使用 Object.defineProperty 的方式定义完成数据响应式，而是使用 Proxy。
- **Proxy 本身效率就比 Object.defineProperty 高，因为不必递归遍历所有属性，而是直接得到一个 Proxy。所以在 vue3 中，对数据的访问是动态的，当访问某个属性的时候，再动态的获取和设置，这就极大的提升了在组件初始阶段的效率**。
- **同时，由于 Proxy 可以监控到成员的新增和删除，因此，在 vue3 中新增成员、删除成员、索引访问等均可以触发重新渲染，而这些在 vue2 中是难以做到的**。

