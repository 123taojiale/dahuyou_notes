## 02. vue3的重大变化 {ignore}

[toc]

### 前言

- 时长：

### "vue" 的默认导出

- vue2 中的 main.js

在 vue2 中，生成的 main.js 的默认内容如下：

```js
import Vue from 'vue'
import App from './App.vue'

Vue.config.productionTip = false

new Vue({
  render: h => h(App),
}).$mount('#app')
```

- 默认导出

`import Vue from 'vue'`

由于，在 `"vue"`（vue库） 中，将 `Vue`（Vue实例的构造函数） 作为默认导出，所以我们才能使用该语句将默认导出的构造器 `Vue` 导入到我们的工程中来创建 Vue实例。但是，在 vue3 中，`"vue"`（vue库）不存在默认导出，如果我们还是使用 vue2 这样的形式来写，那么是会报错的（下图是报错信息）。

![20211013171028](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211013171028.png)

> `Uncaught SyntaxError: The requested module '/@modules/vue.js' does not provide an export named 'default'`
> 意思是：`/@modules/vue.js` 没有给我们提供默认导出。

- vue3 的 main.js

既然传统的 vue2 的 main.js 的写法在 vue3 工程中不被支持，那么使用 vue3 创建的工程，main.js 的默认内容又是什么呢？

下面这是使用 vue3 搭建的工程的 main.js 的默认写法：

```js
import { createApp } from 'vue'
import App from './App.vue'
import './index.css'

createApp(App).mount('#app')
```

- 基本导出 createApp

从 vue3 工程的 mian.js 的默认内容中，我们从 `"/@modules/vue.js"`（就是`"vue"`） 中导出了一个基本导出到 main.js 中。这个基本导出 createApp 就是我们在 vue3 中，用于创建 Vue实例 的构造函数。我们通常会将工程的根组件 App.vue 作为该构造函数的参数传递给它。

对于上述提到的这一点，vue3 是没有兼容 vue2 的。这样的更新，我们通常称为“截断式”（breaking）的更新。

### Vue.use() 和 app.use()

- vue2 的 Vue.use()

vue2 工程，如果要使用某个插件（比如：vue-router），得采用下面这种写法：

```js
import Vue from 'vue'
import VueRouter from 'vue-router'

Vue.use(VueRouter)
```

- vue3 的 app.use()

由于我们前面提到，vue3 中已经不存在默认导出 Vue 了，那么，在 vue3 中，我们想要使用一个插件，写法自然也会发生变化。下面是 vue3 的写法：

```js
import { createApp } from "vue"
import VueRouter from 'vue-router'
import App from "./App.vue"

const app = new createApp(App);
app.use(VueRouter);
```

### this

在 vue3 中写组件时，依旧支持传统的配置式写法，以下面这样的一个简单案例为例：

```html
<template>
  <p>
    <button @click="increase">count：{{ count }}</button>
  </p>
</template>

<script>
export default {
  data() {
    return {
      count: 0,
    };
  },
  methods: {
    increase() {
      console.log('this => ', this);
      this.count++;
    },
  },
};
</script>
```

这种写法在 vue2、vue3 中都是有效的，这一点，vue3 兼容之前的 vue2。

但是，不同点在于 this 的指向。

- vue2 中，this 指向当前组件实例；
- vue3 中，this 指向当前组件实例的代理对象；

![20211013174020](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211013174020.png)

> 代理、反射（proxy、reflet）是 es6 中的内容。

![20211013173813](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211013173813.png)

### option api、composition api

像是上面写的这个组件，它就是使用传统的 option api 来实现的。但是，vue3 出现后，它不仅支持原来 vue2 的 option api 的形式来书写组件，还支持 composition api 的形式来书写我们的组件。

这两种 api 最直观的对比：

![20211013174736](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211013174736.png)![20211013174751](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211013174751.png)

这两张图是使用 composition api、option api 来实现 TODO MVC 的最终代码。前者是 composition api，后者是 option api。不同的颜色块，表示不同的功能块。通过看这两张图我们就能很直观得看出 composition api 能够使我们的功能块更加紧凑，而使用传统的 option api 则会显得我们的功能块很凌乱，给人东一块西一块的感觉。组件的功能越是复杂，这种对比就越是明显。

> 并不是说 composition api 出来后，就再也不用 option api 了。若组件很简单，功能也很单一，我们也许还会使用 option api 来写。

通过了解以上内容，我们就不难得知，vue3 要整出个 composition api 的原因了。

而 vue2 升级到 vue3，最重大的变化也就是这个 composition api。我们后边学习的重点，就在于 composition api 的学习。

### setup()

> 官方文档：[Setup](https://v3.cn.vuejs.org/guide/composition-api-setup.html)
> 有关 setup 这个 composition api 的相关说明，可以查阅官方文档，笔记里仅做一些简单的介绍。

```js
export default {
  setup() {
    // => 函数体
  }
}
```

- 何时调用

setup()，该函数会在当前组件的属性赋值完成后调用，即：所有声明周期钩子函数之前调用。

- this 指向

该函数中是不能使用 `this.xxx` 的，因为 this 指向 undefined。

- 对象返回值

返回的对象身上的属性，将被注入到组件实例中，我们可以直接在模板中使用这些属性。

### ref()

> 官方文档：[ref](https://v3.cn.vuejs.org/api/refs-api.html#ref)

- 作用

接收一个内部值并返回一个**响应式且可变**的 ref 对象。ref 对象具有指向内部值的单个 property.value。说简单点，就是让数据变为响应式数据。

- 实现原理

![20211013182055](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211013182055.png)

ref 的实现原理就是走代理 proxy。
