## 02. 【vue】虚拟DOM详解 {ignore}

[toc]

### 前言

- 时长：

**Summary**

面试题：请你阐述一下对 vue 虚拟 DOM 的理解。

### 什么是虚拟 DOM？

虚拟 DOM 本质上就是**一个用于描述视图的界面结构的普通的 JS 对象**。

在 vue 中，每个组件都有一个对应的 render 函数，每个 render 函数都会返回一个虚拟 DOM 树，这也就意味着**每个组件都对应一棵虚拟 DOM 树**。

![20211127211013](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211127211013.png)

### 为什么需要虚拟 DOM？

在 vue 中，渲染视图会调用 render 函数，这种渲染不仅发生在**组件创建时**，同时发生在**视图依赖的数据更新时**。如果在渲染时，直接使用真实 DOM，由于真实 DOM 的创建、更新、插入等操作会带来大量的性能损耗，从而就会极大的降低渲染效率。

因此，vue 在渲染时，使用虚拟 DOM 来替代真实 DOM，主要为解决渲染效率的问题。

简单来说，就是频繁操作真实 DOM 元素的成本太高。可以使用虚拟 DOM，每个虚拟 DOM 对应一个真实 DOM，使用虚拟 DOM 先将必要的改动给记录下来，然后再一次性操作真实 DOM。

**Attention**

组件在创建时，因为既要准备好虚拟 DOM，又要操作真实 DOM，所以此时的成本，其实是比我们单独操作真实 DOM 还要高的。但是，后续视图所依赖的响应式数据发生变化时，再去重新生成 render 函数，更新视图，成本就会降低很多。

### 虚拟 DOM 是如何转换为真实 DOM 的？

在一个组件实例首次被渲染时，它先生成虚拟 DOM 树，然后根据虚拟 DOM 树创建真实 DOM，并把真实 DOM 挂载到页面中合适的位置。当挂载操作结束后，每个虚拟 DOM 便会对应一个真实的 DOM。

如果一个组件受响应式数据变化的影响，需要重新渲染时，它仍然会重新调用 render 函数，创建出一个新的虚拟 DOM 树，用新树和旧树对比。通过对比，vue 会找到**最小更新量**，然后更新必要的虚拟 DOM 节点。最后，这些更新过的虚拟节点，会去修改它们对应的真实DOM。这样一来，就保证了对真实 DOM 达到最小的改动。

![20211128194615](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211128194615.png)

### 模板和虚拟 DOM 的关系

**compile**

vue 框架中有一个 `compile` 模块，它主要负责将模板转换为 `render` 函数，而 `render` 函数调用后，将得到虚拟 DOM。

`compile` 模块编译模板生成 `render` 函数的过程，可以分为下面两步。

1. 将模板字符串转换成为 `AST`；
2. 将 `AST` 转换为 `render` 函数；

**运行时编译**

如果使用传统的引入方式，则编译时间发生在组件第一次加载时，这称之为运行时编译。

```html
<html>
  <body>
    <script src="xxx"></script>
  </body>
</html>
```

**模板预编译**

如果是在 `vue-cli` 的默认配置下，编译发生在打包时，这称之为模板预编译。

编译是一个极其耗费性能的操作，预编译可以有效的提高运行时的性能。而且，由于运行的时候已不需要编译，`vue-cli` 在打包时会排除掉 `vue` 中的 `compile` 模块，以减少打包体积。

工程化项目，也就是我们使用构建工具搭建的 vue 项目，在默认情况下，使用的都是模板预编译这种模式。当然，我们也可以修改配置文件中的配置项 [runtimeCompiler](https://cli.vuejs.org/zh/config/#runtimecompiler)，在打包结果中保留 compile 模板编译模块。

**模板的意义**

模板的存在，仅仅是为了让开发人员更加方便的书写界面代码。

**vue 最终运行的时候，最终需要的是 render 函数，而不是模板。因此，模板中的各种语法，在虚拟 DOM 中都是不存在的，它们都会变成虚拟 DOM 的配置**。

