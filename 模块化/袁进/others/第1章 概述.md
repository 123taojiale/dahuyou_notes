# 第1章 概述

```
先大致地认识一下模块化的发展史，有助于更好的理解模块化。
学习模块化的目的就是为了开发大型项目，如果没有模块化的话，我们在开发大型应用的时候就会很痛苦。
模块化解决的就是开发大型应用时所遇到的一些问题。
PS：下面介绍的这四个阶段是袁老为了方便讲解才这么划分的，并非啥标准。

问：什么是模块化？
答：就是不同的功能模块丢到不同的文件中，并且文件之间形成一种良好且清晰的依赖关系，模块之间不会造成污染。
    每一门能够开发大型应用的语言，都具有良好的模块化，比如Java语言中，使用“包”来实现，C#语言叫动态链接库（命名空间）。
    PS：这里所说的命名空间和咋们之前学习的那个命名空间表示的含义并不相同。
```

## 1-1. 模块化发展史

本节介绍的是 JavaScript 模块化发展史。

### 第一阶段

在 JavaScript 语言刚刚诞生的时候，它仅仅用于实现页面中的一些小效果，比如一些漂浮的小广告、鼠标hover时的字体颜色发生变化，等等。

那个时候，一个页面所用到的 JS 可能只有区区几百行的代码，代码量并不多，模块化压根就没有出现的必要。

在这种情况下，语言本身所存在的一些缺陷往往被大家有意的忽略，因为程序的规模实在太小，只要开发人员小心谨慎，往往不会造成什么问题。

在这个阶段，也不存在专业的前端工程师，由于前端要做的事情实在太少，因此这一部分工作往往由后端工程师顺带完成。（那个年代还没有前端工程师、后端工程师的说法，统一叫软件开发工程师。）

第一阶段发生的大事件：

- 1996年，NetScape将JavaScript语言提交给欧洲的一个标准制定阻止ECMA（欧洲计算机制造商协会）。
- 1998年，NetScape在与微软浏览器IE的竞争中失利，宣布破产，1999年，它已被AOL在2017年收购了。

```
AOL ==> America Online
ECMA ==> European Computer Manufacturers Association
```

### 第二阶段

ajax的出现，逐渐改变了 JavaScript 在浏览器中扮演的角色。现在，它不仅可以实现小的效果，还可以和服务器之间进行交互，以更好的体验来改变数据。

JS代码的数量开始逐渐增长，从最初的几百行，到后来的几万行，前端程序逐渐变得复杂。

后端开发者压力逐渐增加，致使一些公司开始招募专业的前端开发者。

但那时，前端开发者的待遇远不及后端开发者，因为前端开发者承担的开发任务相对于后端开发来说，还是比较简单的，大多数人通过短短一个月的集训，就可以满足前端开发的需要。

究其根本原因，是因为前端开发还有几个大的问题没有解决，这些问题都严重的制约了前端程序的规模进一步扩大：

1. **浏览器解释执行JS的速度太慢**
2. **用户端的电脑配置不足**
3. 更多的代码带来了全局变量污染、依赖关系混乱等问题

```
当时的浏览器主要用的都是IE浏览器，在那个年代，JS跑在IE上的速度极慢，用户体验很不好。
当时的PC配置和现在的PC配置没法比，1G的内存在当时就算是大的了。
在前面两个问题没有得到解决之前，第3个问题都没有思考的必要。
    PS：第三个问题在当时的解决方案很好理解，在开发一些大型应用的时候，公司会给不同的模块制定不同的命名规范，比如在变量的前边加上模块名和下划线 模块名_ 来解决。
    有些同学可能会想到使用立即执行函数来实现：“避免全局遍历污染的问题”。但是，使用立即执行函数的话，虽然可以把变量保存到局部，不影响全局。但是这么做的话还是会存在新的问题，就是不同模块之间如果存在联系，比方说模块A需要用到模块B中定义的一个函数，因为模块B中的函数被定义到了局部，那模块A就无法获取到模块B中定义的函数了。所以说，立即执行函数并不能很好的解决当时JS在开发大型应用的第3点问题。
```

上面三个问题，就像是阿喀琉斯之踵，成为前端开发挥之不去的阴影和原罪。

> [阿喀琉斯之踵 百度百科](https://baike.baidu.com/item/%E9%98%BF%E5%96%80%E7%90%89%E6%96%AF%E4%B9%8B%E8%B8%B5/340132?fr=aladdin)

在这个阶段，前端开发处在一个非常尴尬的境地，它在传统的开发模式和前后端分离之间无助的徘徊。

第二阶段的大事件：

1. IE浏览器制霸市场后，几乎不再更新。
2. ES4.0流产，导致JS语言10年间几乎毫无变化。
3. 2008年ES5发布，仅解决了一些 JS API 不足的糟糕局面。

### 第三阶段

时间继续向前推移，到了2008年，谷歌的 V8 引擎发布，将JS的执行速度推上了一个新的台阶，甚至可以和后端语言媲美。

```
V8 引擎让 JavaScript 这一门解释型语言跑的跟编译型语言差不多一样快。解决了 JS 执行速度慢的问题。
```

摩尔定律持续发酵，个人电脑的配置开始飞跃。

```
解决了电脑硬件配置的问题。
```

突然间，制约前端发展的两大问题得以解决，此时，只剩下最后一个问题还在负隅顽抗，即**全局变量污染和依赖混乱**的问题，解决了它，前端便可以突破一切障碍，未来无可限量。

于是，全世界的前端开发者在社区中激烈的讨论，想要为这个问题寻求解决之道......

2008年，有一个名叫 Ryan Dahl 小伙子正在为一件事焦头烂额，它需要在服务器端手写一个高性能的web服务，该服务对于性能要求之高，以至于目前市面上已有的web服务产品都满足不了需求。

```
NodeJS 它爹 ==> Ryan Dahl
```

经过分析，它确定，如果要实现高性能，那么必须要尽可能的减少线程，而要减少线程，避免不了要实用异步的处理方案。

一开始，他打算自己实用C/C++语言来编写，可是这一过程实在太痛苦。

就在他一筹莫展的时候，谷歌 V8 引擎的发布引起了他的注意，他突然发现，JS不就是最好的实现web服务的语言吗？它天生就是单线程，并且是基于异步的！有了V8引擎的支撑，它的执行速度完全可以撑起一个服务器。而且V8是鼎鼎大名的谷歌公司发布的，谷歌一定会不断的优化V8，有这种又省钱又省力的好事，我干嘛还要自己去写呢？

于是，它基于开源的V8引擎，对源代码作了一些修改，便快速地完成了该项目。

2009年，Ryan推出了该web服务项目，命名为nodejs。

从此，JS第一次堂堂正正的入住后端，不再是必须附属于浏览器的“玩具”语言了。

也是从此刻开始，人们认识到，JS（ES）是一门真正的语言，它依附于运行环境（运行时）（宿主程序）而执行。

![20210523181839](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210523181839.png)

nodejs的诞生，便把JS中的最后一个问题放到了台前，即**全局变量污染和依赖混乱**问题。

要知道，nodejs是服务器端，如果不解决这个问题，分模块开发就无从实现，而模块化开发是所有后端程序必不可少的内容。

经过社区的激烈讨论，最终，形成了一个模块化方案，即鼎鼎大名的CommonJS，该方案，彻底解决了全局变量污染和依赖混乱的问题。

该方案一出，立即被nodejs支持，于是，nodejs成为了第一个为JS语言实现模块化的平台，为前端接下来的迅猛发展奠定了实践基础。

该阶段发生的大事件：

- 2008年，V8发布。
- IE的市场逐步被 firefox 和 chrome 蚕食，现已无力回天。
- 2009年，nodejs发布，并附带commonjs模块化标准。

### 第四阶段

CommonJS的出现打开了前端开发者的思路。

既然后端可以使用模块化的JS，作为JS语言的老东家浏览器为什么不行呢？

于是，开始有人想办法把CommonJS运用到浏览器中。

可是这里面存在诸多的困难（课程中详解）。

办法总比困难多，有些开发者就想，既然CommonJS运用到浏览器困难，我们干嘛不自己重新定一个模块化的标准出来，难道就一定要用CommonJS标准吗？

于是很快，AMD规范出炉，它解决的问题和CommonJS一样，但是可以更好的适应浏览器环境。

相继的，CMD规范出炉，它对AMD规范进行了改进。

这些行为，都受到了ECMA官方的密切关注......

2015年，ES6发布，它提出了官方的模块化解决方案 —— ES6 模块化。

从此以后，模块化成为了JS本身特有的性质，这门语言终于有了和其他语言较量的资本，成为了可以编写大型应用的正式语言。

于此同时，很多开发者、技术厂商早已预见到JS的无穷潜力，于是有了下面的故事：

- 既然JS也能编写大型应用，那么自然也需要像其他语言那样有解决复杂问题的开发框架
  - Angular、React、Vue等前端开发框架出现
  - Express、Koa等后端开发框架出现
  - 各种后端数据库驱动出现
- 要开发大型应用，自然少不了各种实用的第三方库的支持
  - npm包管理器出现，使用第三方库变得极其方便
  - webpack等构建工具出现，专门用于打包和部署
- 既然JS可以放到服务器环境，为什么不能放到其他终端环境呢？
  - Electron发布，可以使用JS语言开发桌面应用程序
  - RN和Vuex等技术发布，可以使用JS语言编写移动端应用程序
  - 各种小程序出现，可以使用JS编写依附于其他应用的小程序
  - 目前还有很多厂商致力于将JS应用到各种其他的终端设备，最终形成大前端生态

> 可以看到，模块化的出现，是JS通向大型应用的基石，学习好模块化，变具备了编写大型应用的基本功。

```
小结：
    模块化这一部分的知识非常重要，后续课程主要会介4个部分的内容：
    1. CommonJS （重点）
    2. AMD
    3. CMD
    4. ES6 模块化 （重点）
    PS：知识点并不难，但很重要。2和3之所以不重要了，是因为 ES6 模块化的出现。
```