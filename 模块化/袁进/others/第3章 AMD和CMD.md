# 第3章 AMD和CMD {ignore}

[toc]

## 3-1. 浏览器端模块化的难题

```
本节课主要内容：讲解 为何会出现 AMD 和 CMD 规范，认识它们的出现的原因。即：为什么有了 CommonJS规范 之后，还有整出个 AMD、CMD，为什么 CommonJS 在浏览器端用不了，都出现了哪些问题。
相对于后续课程中对 AMD、CMD 规范的介绍，本节课的内容更加重要。
```

**CommonJS的工作原理**

当使用```require(模块路径)```导入一个模块时，node会做以下两件事情（不考虑模块缓存）：

1. 通过模块路径找到本机文件，并读取文件内容。
2. 将文件中的代码放入到一个函数环境中执行，并将执行后`module.exports`的值作为`require函数`的返回结果。

正是这两个步骤，使得CommonJS在node端可以良好的被支持。

可以认为，**CommonJS是同步的**，必须要等到加载完文件并执行完代码后才能继续向后执行。

==为什么 CommonJS 是同步的？==

**当浏览器遇到CommonJS**

当想要把CommonJS放到浏览器端时，就遇到了一些挑战。

1. 浏览器要加载JS文件，需要远程从服务器读取，而网络传输的效率远远低于node环境中读取本地文件的效率。由于CommonJS是同步的，这会极大的降低运行性能。
2. 如果需要读取JS文件内容并把它放入到一个环境中执行，需要浏览器厂商的支持，可是浏览器厂商不愿意提供支持，最大的原因是CommonJS属于社区标准，并非官方标准。

```
1. 文件读取的速度方面，虽然从本地的磁盘中读取文件的速度比从内存中读取文件的速度慢，但是相对于从远程的服务器读取文件（得考虑的因素很多，网速快慢啥的。）而言，还是要快很多的。而且nodejs读取完文件后还会有缓存呢，除了第一次是从磁盘中读取，后续的每一次其实就直接从缓存中读取，速度还会快很多。
2. 对于浏览器厂商不提供支持，我的理解是：
    - 显得官方没有权威。
      这就好比当时出现了一个很好的解决模块化问题的方式，但是这个方式并不是由官方提出的，而是民间的开发者提出的。即便这方法是真的好使，但是如果因此就修改浏览器的底层实现，来配合这一民间提出的方案，那后期如果又有啥类似的情况，那。。。。。。这样的事儿，也许就会不断地发生。
    - 不便于后期的维护。
      个人认为：浏览器底层实现是很复杂的，如果随意地增增减减，那后期想要维护起来就会很困难。当时民间提出的方案，也许只是在当时被认为是比较合适的，如果后期还有升级，更新啥的，那当时所提出的方案是否又会被摒弃掉呢，这样的话，一些产品的兼容性又会出现问题。
    - 该问题并不是非得官方出面才能解决。
      就算官方不出面修改底层实现来提供支持，民间也有很多方式可以暴力解决。
```

**新的规范**

基于以上两点原因，浏览器无法支持模块化，可这并不代表模块化不能在浏览器中实现，要在浏览器中实现模块化，只要能解决上面的两个问题就行了。解决办法其实很简单：

1. 远程加载JS浪费了时间？
   - 做成异步即可，加载完成后调用一个回调就行了。
2. 模块中的代码需要放置到函数中执行？
   - 编写模块时，直接放函数中就行了。

基于这种简单有效的思路，出现了AMD和CMD规范，有效地解决了浏览器模块化的问题。

## 3-2. AMD

全称是Asynchronous Module Definition，即异步模块加载机制。`require.js`实现了AMD规范。在AMD中，导入和导出模块的代码，都必须放置在define函数中。

```html
<!--
    data-main：属性值是 入口文件的路径
    src：属性值是 require.js 文件
    入口文件的实现原理：很简单，就是在 require.js 中读取script标签身上的 data-main 属性的属性值，然后创建一个 script 标签，并将它的 src 属性的属性值设置为从 data-main 中读取到的属性值，然后再插入到页面中即可。
-->
<script data-main="./index.js" src="./require.js"></script>
```

```js
// 需要引入 require.js 文件，该文件在 assets 文件夹下有，也可以在网上找。
define([依赖的模块列表], function(模块名称列表){ // 等待依赖的模块列表加载完成后，再继续执行函数体的内容。依赖模块的导出内容，将作为函数体的参数依次传入，以此来实现模块的导入。
    //模块内部的代码
    return 导出的内容
})
// define的参数很灵活，还有其他的传参方式，but，这并不重要，了解即可。
/* define(function (require, exports, module) {
    module.exports = 导出的内容; // 给 习惯使用 CommonJS 的开发人员 提供便利，函数体中的书写规范，和CommonJS完全一样。
}); */
// PS：第二种 define 的调用方式，是 CMD sea.js 先实现的，然后 AMD 的 require.js 再参考 CMD，新增的一种 define 函数的调用方式。可以说 AMD 及实现了 AMD 规范，又实现了 CMD 规范。
```

> AMD 和 CMD 了解一下即可，不用做过多的练习。

## 3-3. CMD

全称是Common Module Definition，公共模块定义规范，`sea.js`实现了CMD规范，在CMD中，导入和导出模块的代码，都必须放置在define函数中。

> sea.js 是一位淘宝的工程师（玉伯）写的。
> 微博：https://weibo.com/lifesinger?is_all=1

```html
<!-- 和 AMD 的不同点：入口文件如何书写
AMD 的写法：<script data-main="./index.js" src="./require.js"></script>
CMD 的写法如下： -->
<script src="./require.js"></script>
<script>
    seajs.use('./index.js');
</script>
```

```js
define(function(require, exports, module){
    //模块内部的代码
})
```

```
CMD 和 AMD 的实现原理都差不多，但是前者更加好用，因为它更加类似于 CommonJS。
```