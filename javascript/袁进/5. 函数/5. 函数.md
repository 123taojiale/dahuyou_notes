# 5. 函数

[toc]

## 5-1. 函数语法

### 函数的作用

函数主要用于减少重复代码。因为重复代码，让程序难以维护。

在开发时，我们通常会将一个个功能（代码块）给封装成一个个函数，以便我们后续调用。当我们需要使用某个功能时，再调用这些封装好的函数即可，就不需要再写大量的重复代码了。

### 创建（定义、声明）函数

```js
// 通过函数字面量的形式来声明函数
function 函数名(){
  // 函数体
}
```

函数体的代码不会直接运行，必须要手动调用函数，才能运行其中的代码。

### 调用函数

```js
// 语法
函数名(); // 运行函数体
```

调用函数的很简单，只要在函数名儿的后边加上一对小括号即可。

### 函数的三要素

- 函数名
- 函数参数
- 返回值

函数名：就是我们在定义函数的时候，给函数起的名儿。

函数参数：通常，我们在调用函数的时候，都会传入一些参数，我们所传入的这些参数，就是函数参数。

返回值：调用函数的式子，它本质上也就是一个普通的 js 表达式，既然是表达式，自然就会有返回值。函数的返回值，就是我们在调用函数后，函数返回给我们的结果。

### 函数提升

```html
<script>
  test(); // => test
  function test() {
    console.log('test');
  }
</script>
```

我们在定义 test函数 之前，调用了它，这为什么没有报错，就是因为函数提升导致的。

它的等效代码如下：

```html
<script>
  function test() {
    console.log('test');
  }
  test(); // => test
</script>
```

虽然，test函数 定义在后边，但是，在执行时，它会默认被提升到顶部，即：提前帮我们定义好 test函数。所以，我们调用 test函数 时，并没有报错：该函数不存在。

```html
<script>
  test(); // => Uncaught ReferenceError: test is not defined
</script>
<script>
  function test() {
    console.log('test');
  }
</script>
```

通过字面量声明的函数，会提升到 脚本块（script 元素） 的顶部。但是，并不会越过脚本块。

```
【阅读报错信息】
Uncaught ReferenceError: test is not defined
这句报错信息的含义是：抛出了一个未捕获的引用错误，test 没有定义。
ReferenceError => 引用错误
通常，当我们获取一个作用域中不存在的变量（函数可以看做是一个变量）时，就会抛出该错误。
通俗点说，就是找不到 test。
```

---

```js
function test() {
  // 函数体
}
window.test === test; // => true
```

通过字面量声明的函数，会成为全局对象的属性。

### typeof 函数名

使用 typeof 关键字来判断一个变量的类型时，若该变量是函数类型，那么会返回 "function"。

```js
function test() {
  // 函数体
}
typeof test; // "function"
```

### 函数内部声明变量

1. 如果不使用 var 声明，和全局变量一致，表示给全局对象添加属性。（不建议这么干）
2. 如果使用 var 声明，变量提升到所在函数的顶部，函数外部不可以使用该变量。

下面，来看个例子：

```js
function test() {
  a = 1;
  var b = 2;
}
test(); // 执行一遍 test函数
window.a; // => 1
window.b; // => undefined
```

注意：这里需要执行一遍 test函数，让函数体运行一遍。



```
【作用域】
有关作用域的相关知识，在本节暂不做过多介绍，先记住下面几点：
1. 全局作用域、局部作用域
   简单点说，全局作用域就是函数外，局部作用域就是函数内。
2. 函数中声明的变量，仅能在函数中使用，在外部无效；
3. 函数内部可以访问全局作用域中的变量，但是全局不能访问函数局部作用域中的变量；
PS：有关作用域的内容，会在进阶课程 => 作用域 中讲解。
```

### 参数

参数表示函数运行的未知条件，需要调用者告知的数据。

```js
function 函数名(形参1, 形参2, ...){
  // => 函数体
}
函数名(实参);
```

函数参数的有效范围在函数体中。

函数在声明时，需要确认好形参，形参个数可以是0个或多个。

函数调用时传入实参，调用时，并不是说函数定义了几个形参，就要传入几个实参，实参的数量可多可少。多了忽略，相当于没传；少了，相当于缺少的部分传递的是 undefined。

```js
function test(a, b, c) {
  console.log(a, b, c);
}
test(1, 2); // => 1 2 undefined
test(1, 2, 3); // => 1 2 3
test(1, 2, 3, 4); // => 1 2 3
```

### 返回值

函数运行后，得到的结果称为返回值，也就是调用函数的表达式的值。

使用 return 关键字来指定函数的返回值。

- return
  - return 会直接结束整个函数的运行
  - return 后面如果不跟任何数据，返回 undefined
  - 如果函数中没有书写 return，则该函数会在末尾自动 return undefined。

```js
function test() {
  return 1;
}
const val = test(); // 定义一个变量 val，用于存放 test() 函数调用后的返回结果
val; // => 1
```

```js
function test() {
  return;
}
const val = test();
val; // => undefined
```

```js
function test() {
  // => 函数体
}
const val = test();
val; // => undefined
```

### 文档注释

操作: 在 .js 文件下的某个函数声明的前一行，输入 `/**` 后 按 回车 就会自动生成文档注释。

文档注释的目的：为了让函数调用者更直观地了解到该函数的相关功能，以及调用该函数所需要传入的相关参数。

```js
/**
 * 函数的功能描述
 * @param {Number} a 对 形参a 的一些描述信息
 * @param {Number} b 对 形参b 的一些描述信息
 * @param {Number} c 对 形参c 的一些描述信息
 */
function test(a, b, c) {
  // => 函数体
}
```

### 作业

```
通用函数编写, 新建一个js文件，编写以下函数

1. 写一个函数，该函数用于判断某个数是不是奇数
    函数名参考：isOdd

2. 写一个函数，该函数用于判断某个数是不是素数
    函数名参考：isPrime

3. 写一个函数，该函数用于对数组求和
    函数名参考：sumOfArray

4. 写一个函数，该函数用于得到数组中的最大值
    函数名参考：maxOfArray

5. 写一个函数，该函数用于得到数组中的最小值
    函数名参考：minOfArray

6. 写一个函数，该函数用于判断数组是否是稀松数组
    函数名参考：hasEmptyInArray

7. 写一个函数，判断该某年是否是闰年
    函数名参考：isLeap

8. 写一个函数，得到某年某月的天数
    函数名参考：getDays

9. 写一个函数，得到某个数字数组中出现次数最多的数字和频率
    函数名参考：getTopFreqInArray

函数使用
1. 利用上面的某些函数，实现哥德巴赫猜想
    任一大于2的偶数都可写成两个质数之和，比如：8 = 3 + 5
    让用户输入一个大于2的整数，输出其等于哪两个素数相加

2. 让用户输入一个年份，输出该年每个月的天数
```

## 5-2. [作业讲解]函数语法

### 封装常见的函数

#### isOdd

```js
/**
 * 判断一个数是不是奇数
 * @param {number} n 要判断的数字
 * @returns {boolean}
 */
function isOdd(n) {
  return n % 2 !== 0;
}
```

#### isPrime

```js
/**
 * 判断一个数是不是素数
 * @param {*} n
 */
function isPrime(n) {
  if (n < 2) {
    return false;
  }
  for (var i = 2; i < n; i++) {
    if (n % i === 0) {
      return false;
    }
  }
  return true;
}
```

#### sumOfArray

```js
/**
 * 对数组求和
 * @param {*} arr
 */
function sumOfArray(arr) {
  var sum = 0;
  for (var i = 0; i < arr.length; i++) {
    sum += arr[i];
  }
  return sum;
}
```

#### maxOfArray

```js
/**
 * 得到数组中的最大值，如果数组长度为0，则返回undefined
 * @param {*} arr
 */
function maxOfArray(arr) {
  if (arr.length === 0) {
    return;
  }
  var max = arr[0];
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] > max) {
      max = arr[i];
    }
  }
  return max;
}
```

#### minOfArray

```js
/**
 * 得到数组中的最小值，如果数组长度为0，则返回undefined
 * @param {*} arr
 */
function minOfArray(arr) {
  if (arr.length === 0) {
    return;
  }
  var min = arr[0];
  for (var i = 1; i < arr.length; i++) {
    if (arr[i] < min) {
      min = arr[i];
    }
  }
  return min;
}
```

#### hasEmptyInArray

```js
/**
 * 判断一个数组是不是稀松数组
 * @param {*} arr
 */
function hasEmptyInArray(arr) {
  // 稀松数组的特点：下标连续
  for (var i = 0; i < arr.length; i++) {
    if (!(i in arr)) {
      return true;
    }
  }
  return false;
}
```

#### isLeap

```js
/**
 * 判断某年是不是闰年
 * @param {*} year
 */
function isLeap(year) {
  // 4年一闰，百年不闰；400年一闰
  return year % 4 === 0 && year % 100 !== 0 || year % 400 === 0;
}
```

#### getDays

```js
/**
 * 得到某年某月的天数
 * @param {*} year
 * @param {*} month
 */
function getDays(year, month) {
  if (month === 2) {
    return isLeap(year) ? 29 : 28;
  } else if (month < 8 && isOdd(month) || month >= 8 && !isOdd(month)) {
    return 31;
  } else {
    return 30;
  }
}
```

#### getTopFreqInArray

```js
/**
 * 得到数组中出现频率最高的数字和频率
 * 返回一个对象
 * @param {*} arr
 */
function getTopFreqInArray(arr) {
  var records = {}; //记录出现频率
  for (var i = 0; i < arr.length; i++) {
    var n = arr[i];
    if (records[n]) {
      records[n]++;
    } else {
      records[n] = 1;
    }
  }
  var result; //记录最终结果的对象
  for (var prop in records) {
    if (!result || records[prop] > result.frequency) {
      result = {
        number: +prop,
        frequency: records[prop]
      };
    }
  }
  return result;
}
```

### 函数的应用

调用前面封装的函数来实现特定的需求。

#### 验证哥德巴赫猜想

```js
function begin() {
  var num = +prompt("请输入一个大于2的偶数");
  if (isNaN(num) || num <= 2 || isOdd(num)) {
    console.log("输入有误");
    return;
  }
  //输入正确
  for (var i = 2; i <= num - 2; i++) {
    var j = num - i;
    //判断两个数字是否都是素数
    if (isPrime(i) && isPrime(j)) {
      console.log(`${num} = ${i} + ${j}`);
    }
  }
}

begin();
```

#### 获取某年某月的天数

```js
(function begin() { // begin 写或不写，效果都一样。
  var year = +prompt("请输入一个年份（1990~2100）");
  if (isNaN(year) || year < 1990 || year > 2100) {
    console.log("输入有误");
    return;
  }
  //输入正确
  for (var m = 1; m <= 12; m++) {
    console.log(`${year}年${m}月：${getDays(year, m)}`);
  }
}());
```

注意，这种写法表示的是 “立即执行函数”。对于立即指向函数，我们可以将其理解为一个匿名函数，函数名儿，写或者不写，对于它而言，都是一样的。

匿名函数（没有名字的函数，称之为匿名函数），也就是无函数名，它不会有函数声明提升的问题。

匿名函数，由于它没有名字，所以我们不能向普通函数那样调用它。若想要调用一个匿名函数，我们可以使用上面这种形式，将函数声明转化为一个表达式，然后再调用。

```js
(function () {
  // => 函数体
});
```

这是一个函数表达式，而非函数声明。

将函数变为一个函数表达式的方式之一，将函数用小括号括起来。

有关函数表达式的更多内容，见 “5-4. 函数表达式和this”。

## 5-3. 作用域和闭包

### 作用域

作用域表示一个代码区域，也表示一个运行环境。

目前只介绍两种作用域：全局作用域、局部作用域。

在学到ES6时，还会认识到第3种作用域：块级作用域。

### 全局作用域

直接在脚本中书写的代码，就处于局部作用域中。

在全局作用域中声明的变量，会被提升到脚本块的顶部，并且会成为全局对象的属性。

### 局部作用域

局部作用域又称函数作用域。写在函数中的代码，就处于局部作用域中。

在函数作用域中声明的变量，会被提升到函数的顶部，并且不会成为全局对象的属性。因此，函数中声明的变量不会导致全局对象的污染。（不使用关键字，直接声明变量，这是特殊情况，一般不会有人这么做。）

把功能封装在函数中，这样做有很多好处，其中一个就是让实现这些功能的变量不污染全局环境。

### 作用域中可以使用的变量

全局作用域只能使用全局作用域中声明的变量（包括函数）。

函数作用域不仅能使用自身作用域中声明的变量（包括函数），还能使用外部环境的变量（包括函数）。注意: 外部环境 ≠ window，但是，在浏览器环境下，外部环境就是指 window，由于 es 的宿主环境不仅限于浏览器，还有很多其他的宿主环境。

函数内部声明的变量和外部冲突时，使用内部的。

有的时候，某个 函数a 比较复杂，在编写的过程，可能需要另外一些函数来辅助它完成一些功能，而这些函数仅仅会被该 函数a 使用，不会在其他位置使用，则可以将这些函数声明到该函数的内部。（函数里面套函数）

### 闭包

闭包（closure）, 是一种现象，指：内部函数，可以使用外部函数环境中的变量。

## 5-4. 函数表达式和this

### 前言

本节有一些代码示例，请见 codes 目录。

### 函数表达式

JS中，函数也是一个数据，语法上，函数可以用于任何需要数据的地方。JS中，函数是一等公民。函数是一个引用类型，将其赋值给某个变量时，变量中保存的是函数的地址。函数表达式的函数名可以省略，因为没有意义，没啥用。

- 函数表达式的值就是函数本身。

- 当函数成为一个表达式时，它既不会提升（函数声明会提升），也不会污染全局对象。

函数表达式的常见形式：

```js
// 赋值表达式中
const test = function () {
  // => 函数体
}
```

```js
// 小括号中
(function () {})
```

```js
// 对象的成员
const obj = {
  test: function () {},
}
```

```js
// 数组的成员
const arr = [
  function () {},
];
```


### IIFE

将函数变为一个函数表达式的方式之一，将函数用小括号括起来。然而，这样一来，函数就无法通过名称调用。由于大部分情况下，函数表达式的函数名没有实际意义，因此，可以省略函数名。

如果书写一个函数表达式，然后将立即调用，该函数称之为立即执行函数 IIFE（Imdiately Invoked Function Expression）。

```js
(function () {
  console.log('111');
})();
```

111 会立即输出。

### this关键字

在全局作用域中，this关键字始终指向全局对象。

在函数作用域中，取决于函数是如何被调用的：
- 函数直接调用，this指向全局对象
- 通过一个对象的属性调用，格式为 `对象.属性()` 或 `对象["属性"]()`，this指向对象。

注意: 无法给 this 赋值。


## 5. [作业讲解]函数表达式和this

### 前言

本次作业的重点：体验回调函数的使用，就是把 函数a 作为 函数b 的参数，传递给 函数b，由 函数b 在内部决定 函数a 何时调用。

## 5-6. 构造函数

### 对象的方法

若某个对象的属性 a，它的数据类型是函数类型，那么，我们通常也会将该属性成为对象的方法。

示例：

```js
const obj = {
  xxx: function () {
    // => ...
  },
};
```

xxx 是 对象obj 的方法。

### 构造函数

构造函数就是用于创建对象的函数。用函数创建对象，可以减少繁琐的对象创建流程。

- 构造函数的调用

```js
new 构造函数名(参数);
```

- 构造函数的其他特点

函数名通常使用大驼峰命名法。构造函数的命名尽量不要出现 v.（动词），因为关键字 `new` 表示“创建”，已经有一个动词了。

示例：

```js
// 比如要定义一个用于创建用户对象的构造函数
function User() { // 不要命名为：CreateUser
  // => ...
}

const user_a = new User();
// => ...
```

构造函数的返回值是一个对象。

- 构造函数的内部原理

构造函数内部，会自动创建一个新对象，this 指向新创建的对象，并且自动返回新对象。

```js
function User() {
  // this = {}

  // this.xxx = xxx;
  // => ...

  // return this;
}
```

构造函数和普通函数，其实没有啥本质上的却别，它们的区别在于调用方式上，我们在调用一个构造函数的时候，通常会在调用时，加上关键字 new。

一旦我们在调用一个函数时，加上了关键字 new，那么，我们可以简单的理解为，在调用该函数时，它自动地在函数的最前面加上了一行 `this = {};`，并在函数的最后一行加上了 `return this;`。虽然这么理解并不准确，因为关键字 this 是无法被赋值的，但是，这么理解更直观。

- 细节问题

构造函数中如果出现返回值，如果返回的是原始类型，则直接忽略；如果返回的是引用类型，则使用返回的结果。

所有的对象，最终其实都是通过构造函数创建的。


### 如何判断函数是正常调用还是通过关键字 new 来调用

- `new.target`

该表达式在函数中使用，返回的是当前的构造函数。但是，如果该函数不是通过关键字 new 调用的话，则返回 undefined。

通常用于判断某个函数是否是通过 new 在调用。

## 5-7. 函数的本质

### 函数本质

函数的本质就是对象。某些教程中，将构造函数称之为构造器。

构造函数其实就是在调用函数时，加上一个关键字 new。而所有的对象，本质上都是通过构造函数来创建出来的。

而函数本质上就是一个对象，那么，函数也必然是通过构造函数来创建出来的，而创建函数的构造函数，就是 Function。即：所有的函数，都是通过 `new Function(...);` 的方式来创建的。

由于函数本身就是对象，因此函数中，也可以拥有各种属性。

### 包装类

ES 为了增强原始类型的功能，为 boolean、string、number 分别创建了一个构造函数。

- Boolean
- String
- Number

如果语法上，将原始类型当作对象使用时（一般是在使用属性时），ES 会自动在该位置利用对应的构造函数，创建对象来访问原始类型的属性。

说得再直接一点就是，我们都知道，原始类型和引用类型，只有引用类型才有属性，而原始类型是没有属性的。但是，当我们尝试在一个原始类型的数据身上访问属性，有些时候我们却是可以访问到的。这就是包装类在帮我们处理。

下面来看几个示例：

```js
"hello world".length; // => 11
// 等效于 => new String("hello world").length;
```

显然，字符串 `"hello world"`，它就是一个普通的不能再普通的原始类型了，它身上是不可能有啥属性的，但是，我们访问 length 属性时，却没有报错，而且确实获取到了字符串的长度 11。

其实，当我们从 `"hello world"` 身上访问属性时，ES 在内部就帮我们做了处理，调用了字符串的构造函数 String，并将字符串 `"hello world"` 作为其参数传入，临时创建出了一个“字符串”对象，我们实际访问的就是这个临时的“字符串”对象身上的 length 属性。（当我们访问完后，这个被临时创建出来的对象就立刻被销毁了）

```js
3.1415926535.toFixed(2) // 3.14
// 等价 => new Number(3.1415926535).toFixed(2)
```

### Java中的“类”和ES中的构造函数

在学习 Java 时，有“类”的概念。它就好比ES中的构造函数。

### 实例方法和静态方法

成员属性（方法）、实例属性（方法）：表示该属性是通过构造函数创建的对象调用的。

静态属性（方法）、类属性（方法）：表示该属性是通过构造函数本身调用的。

## 5-8. 递归

### 什么是递归？

函数直接或间接调用自身。

### 无限递归

无限递归将会导致栈溢出，应该避免无限递归。

- 无限递归 VS 死循环

无限递归会导致栈溢出，会报错。

死循环不会报错，也不会导致栈溢出，但是会导致程序不断执行，可能会出现死机的情况。

### 执行栈

任何代码的执行都必须有一个执行环境，执行环境为代码的执行提供支持。执行环境是放到执行栈中的。

**每个函数的调用，都需要创建（入栈）一个函数的执行环境，只有在函数调用结束，对应的执行环境才会被销毁（出栈）。**

执行栈有相对固定的大小，如果执行环境太多，执行栈无法容纳，会报错。

### 尾调用和尾递归

如果一个函数最后一条语句是调用函数，并且调用函数不是表达式的一部分，则该语句称为尾调用。

```js
function test() {
  // => ...
  // a(); // 函数 a 就是尾调用
}
```

如果尾调用是调用自身函数，则称为尾递归。

```js
function test() {
  // => ...
  // test(); // 函数 test 就是尾递归
}
```

某些语言或执行环境会对尾调用进行优化，它们会立即销毁当前函数，避免执行栈空间被占用。

在浏览器执行环境中，尾调用没有优化。但在 nodejs 环境中有优化。