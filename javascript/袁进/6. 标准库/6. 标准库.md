# 6. 标准库 {ignore}

[toc]

## 6-1. Object和Function

### 前言

- 时长：

后续我们要学习的内容就是由 **ECMAScript标准** 编写的一系列官方提供的 库（liberary），其实也就是一系列的 API（应用程序编程接口，Application Programing Interface）。

> 前面 1~5 所学习的内容，其实就是 ECMAScript标准。

### Object

- [ ] 静态成员：keys、values、entries

```js
const obj = {
  a: 1,
  b: 2,
  c: 3,
};
Object.keys(obj); // => (3) ['a', 'b', 'c']
Object.values(obj); // => (3) [1, 2, 3]
Object.entries(obj); // => [ ["a", 1], ["b", 2], ["c", 3] ]
```

- keys(某个对象)，得到某个对象的所有属性名数组
- values(某个对象)，得到某个对象的所有属性值数组
- entries(某个对象)，得到某个对象的所有属性名和属性值的数组

- [ ] 实例成员，toString、valueOf

```js
const obj = {
  a: 1,
  b: 2,
  c: 3,
};
obj.toSring(); // => '[object Object]'
obj.valueOf(); // => {a: 1, b: 2, c: 3}
obj.valueOf() === obj; // => true
+obj; // => NaN
// 等价于 +'[object Object]'，尝试将一个不能被转换为数字的字符串转为数字，得到的是 NaN
obj + "123"; // => '[object Object]' + "123" => '[object Object]123'
```

实例成员可以被重写，所有对象，都拥有 Object 的所有实例成员。

- toString 方法：得到某个对象的字符串格式，默认情况下，该方法返回`"[object Object]"`。
- valueOf 方法：得到某个对象的值，默认情况下，返回该对象本身。

在 JS 中，当自动的进行类型转换时，如果要将一个对象进行转换，实际上是先调用对象的 valueOf 方法，然后调用返回结果的 toString 方法，将得到的结果进行进一步转换。

### Function

所有函数实例都具有 Function 中的实例成员：
- length属性：得到函数形参数量。
- apply方法：**调用函数**，同时指定函数中的 this 指向，参数以**数组**的形式来传递。
- call方法：**调用函数**，同时指定函数中的 this 指向，参数以**参数列表**的形式来传递。
- bind方法：**返回一个新函数**，该函数中的 this 始终指向指定的值。

- [ ] test.html

```js
var test = function (a, b) {}
test.length; // => 2
```

test.length 表示函数形参的个数。

- [ ] test.html

```js
function sayHello(a, b) {
  console.log(this.name, this.age);
}

var user1 = {
  name: "foo",
  age: 18
};
/* 要求打印 user1 中的 name 和 age */

// 错误做法：
sayHello(); // 因为 this ==> window 所以不行
user1.sayHello(); // 因为 user1 里面没有 sayHello 这个函数 所以不行。

// 正确做法：
sayHello.apply(user1); // "foo" 18
sayHello.call(user1); // "foo" 18
var newFun = sayHello.bind(user1);
newFun(); // "foo" 18
user1.sayHello = sayHello;
user1.sayHello(); // "foo" 18
```

apply、call、bind 它们都能改变函数中 this 的指向，但是，也存在一些区别。其中 apply、call 会在绑定 this 的同时，将函数给调用一遍，而 bind 仅仅是返回一个新的，并且绑定好 this 的函数，并没有把函数个调用一遍。

- [ ] test.html

```js
function sayHello(a, b) {
  console.log(this.name, this.age, a, b);
}

var user1 = {
  name: "foo",
  age: 18
};

sayHello.apply(user1, [1, 2]); // => "foo" 18 1 2
sayHello.call(user1, 1, 2); // => "foo" 18 1 2
var newFunc = sayHello.bind(user1, 1, 2);
newFunc(); // => "foo" 18 1 2
```

- apply：参数以数组的形式传递；
- call：参数以参数列表的形式传递；
- bind：参数以参数列表的形式传递；

注意：bind 不仅可以绑定 this 的指向，还可以绑定形参。

---

arguments：在函数中使用，获取该函数调用时，传递的所有参数。arguments 是一个**类数组**（也称为**伪数组**，没有通过 Array 构造函数创建的类似于数组结构的对象称为类数组），伪数组会缺少大量的数组实例方法。arguments 数组中的值，会与对应的形参映射。

- [ ] test.html

```js
var test = function abc(a, b) {
  arguments[0] = "abc";
  b = 123;

  a; // => "abc"
  b; // => 123
  arguments; // => ["abc", 123]
}

test(1, 2);
```

```js
var test = function abc(a, b) {
  arguments[0] = "abc";
  b = 123;

  a; // => undefined
  b; // => 123
  arguments; // => ["abc"]
}

test(); // 没有传递参数，所以 arguments 不会与形参映射
```

```js
var test = function abc(a, b) {
  arguments[0] = "abc";
  b = 123;

  a; // => "abc"
  b; // => 123
  arguments; // => ["abc", 123]
}

test(undefined, 2);
```

从上面的例子可以看出，arguments 是否会与形参之间形成映射关系，还得看我们在调用函数的时候，是否有传入参数。若我们传入了参数，那对应位置的形参就会与 arguments 形成映射关系，否则不会有映射。

- [ ] test.html

```js
function test() {
  arguments; // => [1, 2, 3, 4, 5]
  Array.isArray(arguments); // => false
  //将 arguments 转换为真数组
  var newArr = [].slice.call(arguments);
  Array.isArray(newArr); // => true
  newArr; // => [1, 2, 3, 4, 5]
}

test(1, 2, 3, 4, 5);
```

通常，可以利用 apply、call 方法，将某个伪数组转换伪真数组。

- `Array.isArray()` 用于判断数组是真数组还是伪数组。

将一个伪数组转换为一个真数组的方式还有很多，后面会接触到，比如 es6 提供的展开运算符，就可以很轻易的实现，至于其他方式，这里就不作过多介绍了。

```js
function test() {
  arguments; // => [1, 2, 3, 4, 5]
  Array.isArray(arguments); // => false
  const newArr = [...arguments];
  newArr; // => [1, 2, 3, 4, 5]
  Array.isArray(newArr); // => true
}

test(1, 2, 3, 4, 5);
```

## 6-2. Array构造器

### 前言

- 时长：

这节课依旧是介绍相关的 API，这些 API 都比较简单，实在忘记了，直接上网搜就行。代码都在 [code](../codes) 目录下边，把这些常见的一些数组 API 给过一遍，有个印象，可以看懂，就 pass。

### Array 的静态成员和实例成员

凡是通过 Array 构造函数创建的对象，都是数组。

**静态成员**

- from方法：可以将一个伪数组转换为真数组
- isArray方法：判断一个给定的数据，是否为一个真数组
- of方法：类似于中括号创建数组，依次赋予数组每一项的值

**实例成员**

- fill方法：用某个数据填充数组
- pop
- push
- reverse：将当前数组颠倒顺序
- shift
- sort：对数组进行排序
- splice
- unshift

以下是**纯函数**

- concat
- includes: 数组中是否包含满足条件的元素
- join
- slice
- indexOf
- lastIndexOf
- forEach: 遍历数组
- every：是否所有元素都满足条件
- some：是否至少有一个元素满足条件
- filter：过滤，得到满足条件的元素组成的新数组
- find: 查找第一个满足条件的元素，返回元素本身，如果没有找到，返回undefined
- findIndex: 查找第一个满足条件的元素，返回元素的下标
- map：映射，将数组的每一项映射称为另外一项
- reduce：统计，累计

无副作用函数（**纯函数**）：不会导致当前对象发生改变

**reduce**

若面试的时候要问数组的 api，那应该也是问 reduce 这个 api 了，一般会问 reduce 的实现原理。在介绍 reduce 的原理之前，先看看下面的案例，了解一下它的功能。

[Array.prototype.reduce() mdn](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce)

![20210226102951](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210226102951.png)

- [ ] myReduce.js

```js
Array.prototype.myReduce = function (fn, initVal) {
  if (initVal === undefined) {
    initVal = this[0];
    for (let i = 1; i <= this.length - 1; i++) {
      console.log(initVal, this[i], i, this);
      initVal = fn(initVal, this[i], i, this);
    }
    return initVal;
  } else {
    for (let i = 0; i <= this.length - 1; i++) {
      console.log(initVal, this[i], i, this);
      initVal = fn(initVal, this[i], i, this);
    }
    return initVal;
  }
};

let r1 = [0, 1, 2, 3, 4].myReduce(function (p, n) {
  return p + n;
});

let r2 = [0, 1, 2, 3, 4].myReduce(function (p, n) {
  return p + n;
}, 0);

console.log(r2); // => 10
console.log(r1); // => 10
```

对于初学者的我们而言，理解起来还是有点困难的，下面做一个简单地分析：

第一步：先了解一下 reduce 的调用方式，我们在调用 reduce 这个 api 时，有可能会传入两个参数，也有可能只会传入一个参数。对比两者之间的区别。
第二步：观察 accumulator 这个值，不难发现它是再不断累加的，若我们传递了第二个参数，那么 accumulator 的初始值就是我们传入的第二个参数的值；否则，accumulator 为数组的首项。我们在封装 myReduce 方法时，accumulator 应该定义为一个变量，每次调用函数 fn 时，都将该变量作为第一个参数传入，这样就可以实现累加的效果。

像是上面这样仿照原生的 api 来实现一个 myReduce api，我们也称之为 [Polyfill](https://segmentfault.com/a/1190000002593432)，我们在看文档时，看到标题 Polyfil，我们就可以将其理解为仿照原生 api 实现原理的代码。

[reduce Ployfill](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Array/Reduce#polyfill)

> PS：简单看 Ployfill 这一部分，简单看看就好，看懂最好，看不懂说明目前水平还不够。😓

- [ ] 作业.js

```js
/*
var arr = [1, 2, 3, 4, 5, 6, -1, -2, -3, -4, -5, -6];
去掉数组中的负数，然后对每一项平方，然后再对每一项翻倍，然后求和 不许使用循环语句。
*/
var arr = [1, 2, 3, 4, 5, 6, -1, -2, -3, -4, -5, -6];
var result = arr.filter(function (item) {
  return item >= 0;
}).map(function (item) {
  return item * item;
}).map(function (item) {
  return item * 2;
}).reduce(function (sum, item) {
  return sum += item;
}, 0)
console.log(result);
```

## 6-3. [作业讲解]Array构造器

```js
var arr = [1, 2, 3, 4, 5, 6, -1, -2, -3, -4, -5, -6];
// 去掉数组中的负数， 然后对每一项平方， 然后再对每一项翻倍， 然后求和
// 不许使用循环

var result = arr.filter(function (item) {
  return item >= 0;
}).map(function (item) {
  return item ** 2;
}).map(function (item) {
  return item * 2;
}).reduce(function (s, item) {
  return s + item;
}, 0);

console.log(result); // 182
```

## 6-4. 原始类型包装器

### 前言

- 时长：

包装器：Number、Boolean、String

包装器的两种写法：

- `new 包装器(值)`：返回的是一个对象（包装对象）；
- `包装器(值)`：返回的是一个原始类型；

所谓“包装对象”，就是分别与数值、字符串、布尔值相对应的 Number、String、Boolean 三个原生对象。这三个原生对象可以把原始类型的值变成（包装成）对象。

下面介绍的 api，如果忘记了，直接上 mdn 上搜即可。

### Number

静态成员：
- isNaN
- isFinite
- isInteger：判断一个数据是否是整数
- parseFloat：将一个数据转换为小数
- parseInt：将以一个数据转换为整数，直接舍去小数部分
- parseInt、parseFloat：要求参数是一个字符串，如果不是字符串，则会先转换为字符串。从字符串开始位置进行查找，找到第一个有效的数字进行转换，如果没有找到，则返回NaN，左右空白字符会忽略。parseInt，可以传入第二个参数，表示将给定的字符串，识别为多少进制。

实例成员：
- toFixed方法：会有四舍五入
- toPrecision：以指定的精度返回一个数字字符串

### Boolean

空

### String

静态成员：

- fromCharCode：通过 unicode 编码创建字符串

实例成员：

- length：字符串长度
- charAt：得到指定位置的字符
- charCodeAt
- concat
- includes
- endsWith
- startsWith
- indexOf
- lastIndexOf
- **padStart**
  - 常见应用场景：拼接时间时，前面补零。
- padEnd
- repeat
- slice：从某个位置取到某个位置；位置可以是负数；
- substr：从某个位置开始取，取指定的长度；位置可以是负数；
- substring：从某个位置取到某个位置；不可以是负数；参数位置是可调换的。
- toLowerCase
- toUpperCase
- split：分割字符串
- trim
- trimEnd
- trimStart

## 6-5. [作业讲解]原始类型包装器

### 前言

- 时长：

以下练习可以使用之前书写的通用函数。

### 作业

1. 找到某个字符串中出现最多的字符，打印字符和它出现的次数。

```js
// 示例
getTopFreqInArray("absadfgsDfafgsdfgsdfgsadfasdasvasdfsadfasdfa");
// => { char: 'a', frequency: 10 }
```

2. 将一个字符串中单词之间的空格去掉，然后把每个单词首字母转换成大写。

```js
// 示例
bigCamel("hello      woRld        js"); // => HelloWoRldJs
```

3. 书写一个函数，产生一个指定长度的随机字符串，字符串中只能包含大写字母、小写字母、数字。

```js
// 示例
getRandomString(20); // => xDw0bocdhScgwE7wMIFz
```

4. 将字符串按照字符编码的顺序重新升序排序。

```js
// 示例
strSort("bffdgwfafagfdgsfafa"); // => aaaabddfffffffgggsw
```

5. 从一个标准的身份证号中取出用户的出生年月日和性别，保存到对象中。

```js
// 示例
getInfoFromPID("524713199703020014"); // => { birthYear: 1997, birthMonth: 3, birthDay: 2, gender: '男' }
```

## 6-6. Math对象

### 前言

- 时长：

注意：Math 是一个对象，不要误以为它是一个构造函数。

```js
typeof Math; // => Object
```

### Math 对象

Math 对象，提供了一系列与数学相关的成员：
- random方法: 产生一个0~1之间的随机数
- PI属性：得到圆周率
  - 圆周率是一个常量。
  - 常量：永远不会变化的数据。
  - 常量的命名：所有字母大写，如果有多个单词，用下划线分割。
- abs方法：求绝对值
- floor方法：对一个数向下取整
- ceil方法：对一个数向上取整
- max方法：得到一组数字的最大值；如果无参，得到-Infinity
- min方法：得到一组数字的最小值；如果无参，得到Infinity
- pow方法：求一个数字的幂次方
- round方法：得到一个四舍五入的整数


## 6-7. Data构造器

### 前言

- 时长：

### 术语


- 时间单位
  - 年（year）
  - 月（month）
  - 日（date）
  - 小时（hour）
  - 分钟（minute）
  - 秒（second） = 1000ms
  - 毫秒（millisecond，ms） = 1000 us
  - 微秒（microsecond，us） = 1000 ns
  - 纳秒（nanosecond，ns）
- UTC和GMT
  - 世界划分为24个时区，北京在东8区，格林威治在0时区。
  - GMT：Greenwish Mean Time 格林威治世界时。太阳时，精确到毫秒。
  - UTC：Universal Time Coodinated 世界协调时。以原子时间为计时标准，精确到纳秒。
  - UTC和GMT之间误差不超过0.9秒
  - GMT+0800 东8区
- 时间戳
  - 数字
  - 1970-1-1 凌晨 到 某个时刻 所经过的毫秒数

### Date Object

**创建时间对象**

直接调用函数，忽略所有参数，直接返回当前时间的字符串。

```js
Date(); // => 'Mon Oct 25 2021 13:49:33 GMT+0800 (中国标准时间)'
```

使用 new 关键字来调用 Date 构造函数，将返回一个日期对象。

`new Date()`：创建日期对象
- 无参，表示当前时间；
- 1个参数，参数为数字，表示传入的是时间戳；
- 两个参数以上，分别表示：年、月、日、时、分、秒、毫秒
  - 注意：月份的数字从0开始计算。
  - 如果缺失参数，日期部分默认为 1，时分秒毫秒默认为 0。
  - 月、日、时、分、秒、毫秒，均可以传递负数，如果传递负数，会根据指定日期进行计算。

**实例成员**

- getDate方法：得到日期部分
- getDay方法：得到星期几，0表示星期天
- getFullYear方法：得到年份
- getHours方法：得到小时部分
- getMinutes方法：得到分钟部分
- getSeconds方法：得到秒部分
- getMilliseconds方法：得到毫秒部分
- getTime方法：得到时间戳
- getMonth方法：得到月，从0开始计算
- setDate方法：设置日期
- setMonth方法：设置月份
- setFullYear方法：设置年
- setMinutes方法
- setSeconds方法
- setMilliseconds方法
- setTime方法：重新设置时间戳
- toDateString方法：将日期部分转换为可读的字符串。
- toISOString方法：将整个对象转换为ISO标准的字符串格式。
- toLocaleDateString方法：根据当前系统的地区设置，将日期部分转换为可读的字符串
- toLocaleString方法：根据当前系统的地区设置，将整个日期对象转换为可读的字符串
- toLocaleTimeString方法：根据当前系统的地区设置，将时间部分转换为可读的字符串

**日期的运算**

日期对象重写了 Object 中的 valueOf 方法，返回的是一个数字，表示**时间戳**。因此，**日期对象可以进行数学运算**。可以进行数学运算，意味着：我们可以比较两个日期对象的大小（因为会自动调用 valueOf 方法，得到它们的时间戳，再进行比较），可以直接计算天数：`日期对象 ÷ 24 * 60 * 60 * 1000`（每小时 60 分，每分 60秒，每秒 1000毫秒）。

### codes

- [ ] 1.js

```js
Date(); // => Mon Oct 25 2021 13:53:14 GMT+0800 (中国标准时间)
new Date(); // => Mon Oct 25 2021 13:54:27 GMT+0800 (中国标准时间)
new Date(1000); // => Thu Jan 01 1970 08:00:01 GMT+0800 (中国标准时间)
new Date(-1000); // => Thu Jan 01 1970 07:59:59 GMT+0800 (中国标准时间)
new Date(2015, 5, 1, 13, 14, 15, 200); // Mon Jun 01 2015 13:14:15 GMT+0800 (中国标准时间)
new Date(2015, 5); // Mon Jun 01 2015 00:00:00 GMT+0800 (中国标准时间)
new Date(2015, 0, 1); // Thu Jan 01 2015 00:00:00 GMT+0800 (中国标准时间)
new Date(2015, 0, 0); // 提前 1 天 => Wed Dec 31 2014 00:00:00 GMT+0800 (中国标准时间)
new Date(2015, 0, -1); // 提前 2 天 => Tue Dec 30 2014 00:00:00 GMT+0800 (中国标准时间)
/* 注意：
这里传入的时间是北京时间，因为将格林威治时间转换成了北京时间 所以在初始时间的基础上 加了 8 小时。
月份的数字从 0 开始计算，日期是从1开始的。
如果缺失参数，日期部分默认为 1，时分秒毫秒默认为 0。
月、日、时、分、秒、毫秒，均可以传递负数，如果传递负数，会根据指定日期进行计算。
*/
```

- [ ] 2.js

```js
var d = new Date();
// get
d.getDate(); // => 15
d.getDay(); // => 2 => 周三
d.getFullYear(); // => 2020
d.getHours(); // => 19 => 晚上7点
d.getMinutes(); // => 48 => 48分
d.getSeconds(); // => 10 => 10秒
d.getMilliseconds(); // => 588 => 588毫秒
d.getTime(); // => 1600170490588
d.getMonth(); // => 8 => 9月
```

- [ ] 3.js

```js
var d = new Date();
d; // => Tue Sep 15 2020 19:51:31 GMT+0800 (中国标准时间)
d.setDate(14); // 1600084394946 设置日期，返回的是一个时间戳。
d; // Mon Sep 14 2020 19:53:14 GMT+0800 (中国标准时间)
/*
setMonth
setFullYear
setMinutes
setSeconds
setMilliseconds
setTime
*/
```

- [ ] 4.js

```js
// 转换为字符串
var d = new Date();
d.toDateString(); // =>  将日期部分转换为可读的字符串 => Tue Sep 15 2020
d.toISOString(); // =>  将整个对象转换为 ISO 标准的字符串格式 => 2020-09-15T11:57:53.979Z
d.toLocaleDateString(); // => 根据当前系统的地区设置，将日期部分转换为可读的字符串 => 2020/9/15
d.toLocaleString(); // => 根据当前系统的地区设置，将整个日期对象转换为可读的字符串 => 2020/9/15 下午7:57:53
d.toLocaleTimeString(); // => 根据当前系统的地区设置，将时间部分转换为可读的字符串 => 下午7:57:53
```

- [ ] 5.js

```js
/*
日期的运算
日期对象重写了 Object 中的 valueOf 方法，返回的是一个数字，表示时间戳。
因此，日期对象可以进行数学运算。
示例：加 1 天
*/
// 正确写法
var d = new Date();
d; // => Tue Sep 15 2020 20:11:38 GMT+0800 (中国标准时间)
d.setTime(d.valueOf() + 24 * 60 * 60 * 1000); //
d; // => Wed Sep 16 2020 20:11:38 GMT+0800 (中国标准时间)

// 错误写法
var d = new Date();
d; // => Tue Sep 15 2020 20:11:38 GMT+0800 (中国标准时间)
d.setTime(d.getDate() + 1); // d.getDate() + 1 ==> 16
d; // => Thu Jan 01 1970 08:00:00 GMT+0800 (中国标准时间)
```
### 作业

1. 编写一个函数，用于返回一个友好的日期字符串格式
   年-月-日 时:分:秒
2. 给定用户的生日（年、月、日），计算该用户的年龄
   - 扩展：计算还有多少天过生日
3. 根据系统当前的月份，输出这一个月每一天的星期
   2019年6月1日：星期六
   2019年6月2日：星期日
   .....
   2019年6月30日：星期日
   提示：如何获取某个月的天数？
   示例：获取 2021 年 2 月份的天数：`new Date(2021, 2, 0).getDate(); // => 28`
   日期是从 1 开始算的，若传入的日期部分是 0，那么表示上个月的最后一天。


## 6-8. [作业讲解]Data构造器

### 前言

- 时长：

讲解 6-7 中的作业题，相关代码在 codes 目录中。

## 6-9. 正则表达式

### 前言

- 时长：

核心在于看懂 codes 目录下的代码。笔记中的内容仅是对 codes 的一个提炼。

[Regular expressions MDN](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions)

### 基础

#### 什么是正则表达式

正则表达式是**一个规则**，用于**验证字符串**，该规则是**国际标准**，是**跨越语言**的。

有很多和字符串相关的需求，都可以使用正则表达式来实现。以下相关案例，在实际开发中如果想要用正则来实现，那么代码量可能会少很多。

小结：
- 正则就是用来匹配字符串的一种规则；
- 正则表达式就是描述这种规则的式子；

#### 基础知识

- 字面量匹配：规则中直接书写字面量字符
- 特殊字符：`.`、`^`、`$`
- 转义符：转义符可以将特殊字符转义
- 字符集：`[]` 集合
- 量词：`{}` 前面的规则出现的次数

```js
// 特殊字符
.   // 	匹配除换行符 \n 之外的任何单字符。
^   //  匹配输入字符串的开始位置。
$   //  匹配输入字符串的结尾位置。
// 转义符
\n // 匹配一个换行符。
\r // 匹配一个回车符。基本使用不到, 和操作系统有关
\t // 匹配一个制表符。等价于 \x09 和 \cI。
\s // 匹配任何空白字符，包括空格、制表符、换页符等等。等价于 [ \f\n\r\t\v]。注意 Unicode 正则表达式会匹配全角空格符。
\S // 匹配任何非空白字符。等价于 [^ \f\n\r\t\v]。
\b // 匹配一个单词边界，即字与空格间的位置。
\B // 非单词边界匹配。
\d // 匹配一个数字字符。等价于 [0-9]。
\D // 匹配一个非数字字符。等价于 [^0-9]。
\w // 匹配字母、数字、下划线。等价于'[A-Za-z0-9_]'。
\W // 匹配非字母、数字、下划线。等价于 '[^A-Za-z0-9_]'。
\un // 匹配 n，其中 n 是一个用四个十六进制数字表示的 Unicode 字符。例如， \u00A9 匹配版权符号 (©)。\u9676\u5bb6\u4e50 ==> 陶家乐
// 字符集
[字符范围]
[^字符范围] // 对字符范围取反
[\u4e00-\u9FA5] // 匹配中文
[\s\S] 或 [\d\D] 等等 // 匹配所有字符
// 量词
* // 匹配前面的子表达式零次或多次。例如，zo* 能匹配 "z" 以及 "zoo"。* 等价于{0,}。
+ // 匹配前面的子表达式一次或多次。例如，'zo+' 能匹配 "zo" 以及 "zoo"，但不能匹配 "z"。+ 等价于 {1,}。
? // 匹配前面的子表达式零次或一次。例如，"do(es)?" 可以匹配 "do" 或 "does" 。? 等价于 {0,1}。
{n}     匹配n个
{n,}    匹配>=n个
{n,m}   匹配n~m个
```

#### 作业1

1. 写一个正则表达式，匹配手机号
   11位，第一位是1
   `^1\d{10}$`
2. 姓名必须是3-6位的中文
   `^[\u4e00-\u9fa5]{3,6}$`
3. 密码必须是6-12位的字符，只能包含数字、字母、下划线
   `^\w{6,12}$`
4. 写一个正则表达式，匹配邮箱
   xxxxxx@xxxxx.xxxx.xxxx
   `^\w+@\w+(\.\w+){1,2}$`
5. 匹配一个座机号
   xxx-xxxxxxxx
   前面：1-3个数字
   后面：4-8个数字
   `^\d{1,3}-\d{4,8}$`
6. 匹配一个正数
   `^\d+(\.\d+)?$`
   注意两种错误写法:
   - `^\d+\.?\d+$`
     `1` 应该能匹配，但是这种写法无法匹配。
   - `^\d+\.\d*$`
     `1.` 应该不能匹配，但是这种写法能匹配。
7. 匹配一个小数
   `^-?\d+\.\d+$`
8. 匹配一个整数
   `^-?\d+(\.0+)?$`
   默认把小数部分都是0的数字也当成是一个整数

#### 在 JS 中的应用正则

js 中，正则表达式表现为一个对象，该对象是通过构造函数 RegExp 创建的。

创建正则对象的两种方式：
- 字面量模式`/直接书写正则表达式/`
- 构造函数模式`new RegExp("正则表达式")`

开发时，一般情况下，都是直接书写正则表达式，也就是采用第一种方式来创建一个正则表达式；特殊情况: 如果正则表达式是在一个变量里面，比如: 来自用户输入，那么会采用第二种方式来创建一个正则表达式。

实例成员：

| 正则实例成员 | 含义                                                                                  |
| ------------ | ------------------------------------------------------------------------------------- |
| global       | 表示是否开启了全局匹配 readonly                                                       |
| ignoreCase   | 表示是否开启了忽略大小写 readonly                                                     |
| multiline    | 表示是否开启了多行搜索 readonly                                                       |
| source       | 得到规则字符串 `pattern`                                                              |
| test()       | 验证某个字符串是否满足规则                                                            |
| exec()       | execute，执行匹配，得到匹配结果。该方法的返回值是一个数组，数组的第一项是匹配的结果。 |

贪婪模式和非贪婪模式：

| 贪婪模式                           | 非贪婪模式                              |
| ---------------------------------- | --------------------------------------- |
| 正则表达式，默认情况下为贪婪模式。 | 在量词后，加上`?`，表示进入非贪婪模式。 |
| 贪婪模式会尽可能多的匹配           | 贪婪模式会尽可能少的匹配                |

字符串对象中的正则方法：

| 方法                          | 含义                                                                       |
| ----------------------------- | -------------------------------------------------------------------------- |
| `String.prototype.split();`   | 通过分离字符串成子串，将字符串对象分割成字符串数组。                       |
| `String.prototype.replace();` | 被用来在正则表达式和字符串直接比较，然后用**新的子串**来替换被匹配的子串。 |
| `String.prototype.search();`  | 对正则表达式和指定字符串进行匹配搜索，返回**第一个**出现的匹配项的下标。   |
| `String.prototype.match();`   | 使用正则表达式与字符串相比较。                                             |

#### 作业2

1. 书写一个正则表达式，去匹配一个字符串，得到匹配的次数，和匹配的结果
2. 得到一个字符串中中文字符的数量
3. 过滤敏感词，有一个敏感词数组，需要将字符串中出现的敏感词替换为四个星号
   敏感词词库（测试用例）：`["共产党", "too young too simple", "营销"]`
4. 得到一个 html 字符串中出现的章节数量
   `var html = (h2{第$章}+p*5>lorem100)*10`

### 进阶

#### 捕获组和非捕获组

概念：用小括号包裹的部分叫做捕获组，捕获组会出现在匹配结果中。捕获组可以命名，叫做具名捕获组。

若我们不想让某个小括号中的内容成为捕获组中的内容，那么我们只需要在小括号中加上 `?:` 即可，如：`(?:正则)`。（可以提高执行效率）

#### 反向引用

在正则表达式中，使用某个捕获组，`\捕获组编号`。

#### 预查

| 正向断言                                                                           | 负向断言                                                                             |
| ---------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| 检查某个字符后面的字符是否**满足**某个规则，该规则不成为匹配结果，并且不成为捕获组 | 检查某个字符后面的字符是否**不满足**某个规则，该规则不成为匹配结果，并且不称为捕获组 |


## 6-10. 错误处理

### 前言

- 时长：

> 本章节的第三个视频只看了前面的 35min 还有后续的 25min 没有观看。

### 错误对象

错误在 js 中本质上是一个对象，错误对象的构造函数为 Error。

### 错误分类

| 语法错误                   | 运行错误                                             |
| -------------------------- | ---------------------------------------------------- |
| 会导致整个脚本块无法执行。 | 导致当前脚本块后续代码无法执行；运行结果不符合预期。 |

### 错误调试

错误调试，又叫 debug。在 js 中，常见的 debug 方式有下面两种：
- 控制台打印
- 断点调试

> 就笔者而言，从学习前端开始到目前实习俩月为止，基本上都是使用第一种方式来调试。虽然断点调试也学习过，但主要还是使用传统方式（打印）来调。当然，这也不排除之后可能会更青睐断点调试的方式。

### 抛出错误和捕获错误

抛出错误的语法为：`throw 错误对象;`。

捕获错误：

```js
try{
  // 代码块1
}
catch(错误对象){
  // 代码块2
}
finally{
  // 代码块3
}
```

执行逻辑：执行代码块1，若执行过程中发生了错误，那么立即停止代码1的执行，转而执行代码块2，并将错误对象作为 catch 的参数传入。无论代码块1是否发生错误，代码块3始终都会执行。

