## 4-8. 数组 {ignore}

[toc]


### 什么是数组？

可以将数组理解为一种集合，它可以存放多个数据。我们后面还会接触很多集合，比如 `Object`、`Set`、`Map`，它们都可用于存放多个数据。



### 如何创建一个数组？

```js
const arr = new Array(3) // (3) [empty × 3]
// arr => [ , , , ]
```

使用构造函数来创建一个长度为 3 的数组，数组的每一项都是 undefined。

很少情况下，我们会使用这样的方式来创建一个数组，除非我们有这样的需求：创建一个指定长度的数组，并且数组的每一项为空（undefined）。

```js
const arr = [1, 2, 3];
// 等价写法：
// const arr = new Array(1, 2, 3);
```

使用字面量的形式来创建一个数组：`[数据, 数据, 数据, ....]`。

使用这种方式来创建一个数组，在创建好数组的同时，也对数组的每一项进行了初始化（赋值）。

很多情况下，我们会采用这样的方式来初始化一个数组。这种以字面量形式来创建数组的方式更加常见一些。

一些小细节：
1. 如果我们在调用 Array 函数时，仅传入了一个非负数 x 作为参数，那么它表示的含义是创建一个长度为 x 的数组（数组的每一项都是空）。
2. 如果我们在调用 Array 函数时，传入了多个参数，那么表示的含义就跟上面这种字面量的形式一样。



### 认识数组的本质

在 es 中，数组的本质是一个对象。这个对象身上有一个很常用的属性：`length`。读取该属性，将返回数组的长度，即：数组中的成员数量。

```js
const arr = [1, 1, 1, 1];
arr.length; // => 4
```

注意点：数组的长度等于最后一个成员的索引值 ＋ 1



### 什么是数组的索引（下标）？

前面我们知道了，在 es 中，数组它本质上就是一个对象，我们要访问对象中的成员，可以指定成员的索引（下标）来进行访问。而这些索引就是对象的“数字字符串属性”，相当于数组中每个数据的编号，下标从0开始排列。

```js
const arr = [1, 10, 100, 1000];
arr[0]; // => 访问数组的第 1 个成员，得到的结果是 1
arr[1]; // => ... 2 ... 10
arr[2]; // => ... 3 ... 100
arr[3]; // => ... 4 ... 1000
```

由此可见，数组的下标范围：`0 ~ length -1`

一个小细节：如果给length直接赋值，会导致数组被截断，所以在实际开发中，建议不要给数组的 length 重新赋值，除非特殊需要，否则不建议这么干。

```js
const arr = [1, 10, 100, 1000];
arr.length = 1;
arr; // => [1]
```

```js
const arr = [1, 10, 100, 1000];
arr.length = 6;
arr; // => [1, 10, 100, 1000, , ]
```



### 稀松数组

下标不连续的数组，叫做稀松数组。

通常情况下，数组的下标应该是连续的。但是也有特殊情况，会导致数组的下标不连续，对于下标不连续的数组，我们称之为稀松数组。

![20211010211813](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211010211813.png)



### 数组[长度] = 数据

```js
const arr = [1, 2, 3];
arr[arr.length] = 4;
arr; // => [1, 2, 3, 4]
```

用于在数组末尾添加一个成员。

小细节：这里数组的长度，我们虽然可以直接看出来，只有3个成员，长度是3。所以，我们当然也可以将第二条语句 `arr[arr.length] = 4;` 改为 `arr[3] = 4;` 来达到同样的效果。但是，通常情况下，我们不会采用后面这种写法，因为在实际开发中，我们还想像现在这样，肉眼直观地看出当前数组有多少个成员，那是很不现实的。



### 数组.push(数据)

```js
const arr = [1, 2, 3];
arr.push(4);
arr; // => [1, 2, 3, 4]
```

作用是在数组末尾添加一个成员。

除了上述提到的写法，使用 push 方法来往数组的末尾添加一个成员，也很常用。



### 数组.unshift(数据)

```js
const arr = [1, 2, 3];
arr.unshift(4);
arr; // => [4, 1, 2, 3]
```

作用是在数组起始位置添加一个成员，会导致数组每一项的下标向后移动。


### 数组.splice(下标, 0, 添加的数据)

```js
const arr = [1, 2, 3];
arr.splice(arr.length, 0, 4);
arr; // => [1, 2, 3, 4]
```

作用是从指定下标位置开始，删除0个，然后在该位置插入添加的数据，如果下标超过范围，则按照范围的边界进行处理。

splice 这个 api，它不仅可以往数组中添加成员，还可以删除成员，相对于 push、unshift 这俩 api 而言，它更加的灵活。

PS：push、unshift、splice 也可以添加多个数据，把想要添加的数据依次作为参数写在后边即可。



### delete 数组[下标]

![20211010214258](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211010214258.png)

这种做法不会导致数组其他的属性发生变化，因此，该做法会导致产生稀松数组，所以不推荐使用该做法。



### 数组.pop()

```js
const arr = [1, 2, 3];
arr.pop(); // => 3
arr; // => [1, 2]
```

```js
const arr = [];
arr.pop(); // undefined
```

删除数组的最后一项，该表达式返回最后一项的数据，若数组本身是空 , 那么返回的是 undefined。

注意：`pop()` 这个 api，会改变原数组。



### 数组.shift()

```js
const arr = [1, 2, 3];
arr.shift(); // => 1
arr; // => [2, 3]
```

删除数组第一项，该表达式返回第一项的数据，若数组本身是空 , 那么返回的是 undefined。

注意：`shift()` 这个 api，也会改变原数组。


### 数组.splice(下标, 删除的数量, 添加的数据)

```js
const arr = [1, 2, 3, 4, 5];
arr.splice(1, 2, 100, 1000); // => [2, 3]
arr; // => [1, 100, 1000, 4, 5]
```

从指定下标位置开始，删除指定数量，然后在该位置插入添加的数据。返回一个新数组，该数组记录被删除的数据。

注意：`splice()` 这个 api，也会改变原数组。

细节问题：

我们在调用这些数组的 api 时，给的数组的下标都是正常的情况（下标在 0~arr.length 之间）。

但是，若我们传入的下标不在这个范围内，这些 api 也是可以正常调用的，比方说，我们在使用 splice 这个 api 时，第一个参数就可以传入负数，表示的是倒数第几个。

如：`[1, 2, 3].splice(-1, 1)` 表示的含义就是：从数组 `[1, 2, 3]` 的倒数第一个成员开始，删除一个成员。

```js
[1, 2, 3].splice(-1, 1); // => [3]
[1, 2, 3].splice(-3, 2); // => [1, 2]
```

对于这些细节问题，也就是我们给定的索引不在 （0~arr.length） 范围内的情况，就不细说了。如果不得已用到了，那么可以到控制台上测试测试，或者上 w3school、mdn 上搜一搜。



### 数组.slice(起始位置下标, 结束位置下标)

```js
const arr = [1, 2, 3, 4];
arr.slice(1, 3); // => [2, 3]
arr; // => [1, 2, 3, 4]
```

slice 这个 api，主要用于数组切片。

将起始位置到结束位置之间的数据拿出来，得到一个新的数组，该函数不会改变原数组。

注意：

结束下标取不到，如果用数学上所学的区间来表示的话，那么切片的范围是 `[起始位置下标, 结束位置下标)` 前者是闭区间，表示可以取到，后者是开区间，表示取不到。

```js
const arr = [1, 2, 3, 4];
arr.slice(1); // => [2, 3, 4]
```

如果不写结束下标，则直接取到末尾。

```js
// 等效写法：
const arr = [1, 2, 3, 4];
arr.slice(1, arr.length); // => [2, 3, 4]
```



### 清空数组

依据前面所学到的知识，可知，下面这两种方式都可以清空一个数组。

1. `数组.splice(0, 数组.length);`
2. `数组.length = 0;`



### 数组.indexOf(数据)

```js
[1, 2, 3, 4].indexOf(10); // => -1
[1, 2, 3, 4].indexOf(1); // => 0
```

用于查找数组中某一项的索引值。

从数组中依次查找对应的数据，查找时使用**严格相等**（`===`）进行比较。找到第一个匹配的下标，返回。如果没有找到，则得到-1。



### 数组.lastIndexOf(数据)

```js
[1, 2, 3, 1].lastIndexOf(10); // => -1
[1, 2, 3, 1].lastIndexOf(1); // => 3
```

功能和 `indexOf()` 类似，只是查找的是最后一个匹配的下标。可以理解为，indexOf 是从前往后找，而 lastIndexOf 是从后往前找。



### 数组.fill()

```js
const arr = new Array(3); // 创建一个长度为 3 的空数组
arr; // => [ , , , ]
arr.fill(10); // 将数组的每一项都填充为 10
arr; // => [10, 10, 10]
```

数组.fill(数据)：将数组的所有项，填充为指定的数据。

```js
const arr = [ , , , ]; // 也可以使用字面量的形式来创建一个长度为 3 的空数组
arr.fill(10, 1);
arr; // => [ , 10, 10]
```

数组.fill(数据, 开始下标)：将数组从开始下标起，到数组的末尾，填充为指定的数据。

```js
const arr = [ , , , ];
arr.fill(10, 0, 1);
arr; // => [ 10, , , ]
```

数组.fill(数据, 开始下标，结束下标)：将数组从开始下标起，到数组的结束下标（取不到），填充为指定的数据。

> `[ , , , ]` 这种创建数组的写法，很奇葩，正常情况都不会这么写的，也就记笔记的时候试用一下，体验体验多样的写法。

### in

```js
const arr = new Array(3); // 稀松数组
1 in arr; // => false
```

![20211010233238](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211010233238.png)

这样创建的稀松数组，没有索引。

```js
const arr = [10, 10, 10];
1 in arr; // => true
```

![20211010233356](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211010233356.png)

语法：`属性名 in 对象`

作用：判断某个属性在对象中是否存在。若存在，返回 true，否则返回 false。



### for-in

```js
for(var prop in 对象){
  // 循环体
}
```

取出对象的所有属性名，每次循环将其中一个属性名赋值给变量 prop，运行循环体。

```js{cmd=node}
const arr = [10, 100, 1000];
for(var index in arr){
  // 循环体
  console.log(index, arr[index]);
}
```

