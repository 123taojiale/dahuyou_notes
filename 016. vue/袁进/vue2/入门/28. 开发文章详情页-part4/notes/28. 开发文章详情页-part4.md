# 28. 开发文章详情页-part4

## 前言

- 时长：40

---

效果：文章详情页，滚动到不同的区域时，对应右侧的目录标题将被激活；

> 本节要实现的就是这么一个效果，看起来很简单，不过实现起来比较复杂，需要用到“递归”、“事件总线”、“函数防抖”等核心知识。

---

- [x] 如何封装一个事件总线？
- [x] 如何封装一个函数防抖？
- [x] 如何获取到一个 dom 元素与视口顶边的距离？
  - `dom.getBoundingClientRect().top`
- [x] 如何获取到一个 dom 元素身上的 id 属性值？（如果设置了 id 属性的话）
  - `dom.id`
- [x] 如何确保锚链接可以正常跳转？
  - 【原因】这里说的情况是指页面首次加载时，锚链接无法正常跳转。虽然地址栏中带有锚链接 `#某个标题的id`，但是，由于加载页面元素，组件实例被创建并渲染到页面上，是需要一段时间的，而地址栏的锚链接是一开始就确定好的，一开始时想要跳转，但是压根就还没生成对应的页面元素，所以就导致了无法跳转的问题。
  - 【解决方式】其实原理很简单，既然一开始页面元素还没渲染出来，导致了无法正常跳转，那么，我们就可以在页面元素都渲染出来后，再跳转。逻辑：先获取到地址栏中的 hash 值，保存到一个变量中，然后将地址栏的 hash 值设置为空，最后将变量中保存的 hash 值重新给地址栏中的 hash 值赋值，即：等到元素都渲染出来后，重新设置一遍 hash，设置的还是原来的值。（hash 值的改动，会导致页面重新跳转）
  - ![20210902095114](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210902095114.png) ![20210902100006](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210902100006.png)
  - 既可以写在 updated 钩子函数中，也可以写在 watch 中，只要确保页面元素都加载完了再跳就行。

## 回顾 事件总线

```js
import Vue from "vue";

Vue.prototype.$bus = new Vue({});
```

> 要做到信手捏来

## 回顾 debounce 函数防抖

```js
export default (fn, duration) => {
  let timer = null;
  return (...args) => {
    clearTimeout(timer);
    timer = setTimeout(() => {
      fn(...args);
    }, duration)
  }
}
```

> 也要做到信手捏来
> 写代码时，这样类似的高阶函数（函数里面返回函数）的用法，多关注关注。

## 判断被选中的标题

如何依据当前滚动到的位置，来判断应该选中哪个标题？

![20210901202615](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210901202615.png)

> Range 是我们自定义的一块有效区域，代码中呈现出来就是一个高度值。

做了一个简图，以该图来说明相关逻辑，其实，情况就分 3 种：
1. 如果一个标题正好就在选中区域中，即：标题与页面可视区顶部之间的距离：`[0, range]`，那么，该标题就是选中的，其他标题都不用再判断了。
2. 如果一个标题位于有效区域的上方，即：`< 0`，那么，默认选中该标题，并且继续判断；
3. 如果一个标题位于有效区域的下方，即：`> range`，那么，不再继续往后判断，直接 return；

> 按照上述逻辑来实现，有一个前提，就是服务器返回给我们的 toc 目录数组，标题的 id 依次是从上往下的，即：标题1 是 `toc[0]`，标题2 是 `toc[1]`。。。
> 所以，后续继续参数判断的标题，其实就是位于当前标题下方的其他标题；

## 回顾递归

> 见本节的“代码”目录，模拟本节的相关数据，将递归的逻辑抽离出来单独看。
>
> 共有两处涉及到了递归，在理解了 demo 中的两个 递归.js 文件之后再看 `my-site` 中的相关代码。

## 小结

【实现步骤】

> 建议配合代码一起看

我的：

- 根据父组件传递过来的 toc 目录数组，获取到每一个标题 dom 元素的数组 doms；
  - 因为在 `mainScroll` 事件触发时，需要获取到每一个标题元素与视口的顶部之间的距离（需要操作原生dom），以此来判断当前的滚动距离下，应当被选中的标题是哪个；
- 事件总线
  - BlogTOC.vue 在事件总线上注册 mainScroll 事件，`this.$bus.$on("mainScroll", fn1)`
    - fn1 是指经过函数防抖处理的函数，作用是用于判断依据当前滚动条滚动到的位置，应该选中哪个标题；
    - mounted 阶段注册`$on`，beforeDestroy 阶段取消`$off`；
  - Detail.vue 绑定滚动事件 `this.$refs.mainContainer.addEventListener("scroll", this.handleScroll)` ，一旦滚动，那么就调用 `handleScroll` 通知事件总线上的 `mainScroll` 事件执行，`this.$bus.$emit("mainScroll")`
    - mainContainer 是滚动的区域，即：文章详情页的文章区域；
    - mounted 阶段注册`addEventListener`，beforeDestroy 阶段取消`removeEventListener`；
- 根据父组件传递过来的 toc 目录数组，以及当前应当被选中的那个标题的id，获取带有 isSelect 属性的 toc 数组；

袁老师：

> 实现步骤正好和我的实现步骤相反；
>
> 袁老师是先假设已经知道了当前处于选中效果的标题是哪个，然后再依据这个标题来获取到新的 toc 数组（需要传递给 RightList 组件的数据），即：带有 isSelect 属性的 toc 数组（远程获取到的文章目录是不带有 isSelect 属性的，因为它压根就不知道当前应该选中的是哪个标题）。
>
> 然后，袁老师再试着去写代码，依据当前的滚动位置来获取应该处于选中状态的那个标题。
