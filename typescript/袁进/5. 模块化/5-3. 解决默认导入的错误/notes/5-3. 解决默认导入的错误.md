## 5-3. 解决默认导入的错误

### 前言

- 时长：12min

### commonjs 规范

为了让 js 代码（由 ts 代码编译后生成），能够在 node 环境中的 commonjs 模块化标准下正常运行。我们需要将 module 配置为 commonjs，让编译生成的目标文件使用的模块化规范为 commonjs 规范。

```json
{
  "compilerOptions": {
    "module": "commonjs",
  },
}
```

### 错误写法

**import fs from "fs"**

当我们在 ts 文件中使用 es6 的写法，将 fs 的默认导出导入到变量 fs 中，是会出现错误的。

**原因分析**

虽然，`import fs from "fs"` 会被编译为正常的 commonjs 导入语句：`const fs_1 = require("fs")`。但是，我们在 ts 文件中写的 `fs.xxx` 代码，被编译后会转换为 `fs_1.default.xxx`。这就是为什么我们不能使用上面这种写法来导入 fs 的原因。

```js
// ts
import fs from "fs";
fs.readFileSync("./");
// 编译后生成的 js
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
fs_1.default.readFileSync("./");
```

**导入的模块未使用**

若我们在 ts 中导入了一个模块，但是没有使用该模块，那么该模块的导入语句并不会生成到编译结果中。比如上述代码，若我们只是导入了 fs 模块，但是没有使用该模块，那么导入语句就不会生成到编译结果中。

### 正确写法

**import { readFileSync } from "fs"**

虽然使用默认导出不行，但是我们可以使用基本导出（具名导出），这样导入的内容，编译结果就是正常的。

```js
// ts
import { readFileSync } from "fs";
readFileSync("./")
// 编译后生成的 js
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = require("fs");
(0, fs_1.readFileSync)("./");
```

**新的问题**

fs 中的具名导出那么多，我们不知道具体有哪些具名导出；而且每要使用一个 fs 模块提供的 api，就到在 import 中写上该 api，操作上显得有点繁琐。

**解决方式**

```js
import * as fs from "fs";
```

若我们希望将 fs 模块导出的所有内容，丢到一个变量中，然后我们通过 `变量.xxx` 的形式来访问指定的 api，使用上面这种写法就可以了。

```js
// ts
import * as fs from "fs";
fs.readFileSync("./")
// 编译后生成的 js
Object.defineProperty(exports, "__esModule", { value: true });
const fs = require("fs");
fs.readFileSync("./");
```

### [esModuleInterop](https://www.typescriptlang.org/tsconfig#esModuleInterop)

```js
import fs from "fs"; // => ×
import { readFileSync } from "fs"; // => √
import * as fs from "fs"; // => √
```

虽然前面介绍的两种解决方式，都可以解决我们提到的错误式写法所导致的问题。但是，我们在写代码的时候，还是很有可能会写出错误写法那样的代码。对于该问题，我们加上 esModuleInterop 配置来解决。

```json
{
  "compilerOptions": {
    "esModuleInterop": true,
  },
}
```

在加上该配置过后，我们再来看看原来错误写法的代码：

```js
// ts
import fs from "fs";
fs.readFileSync("./");

// 编译后生成的 js
var __importDefault = (this && this.__importDefault) || function (mod) {
  return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs_1 = __importDefault(require("fs"));
fs_1.default.readFileSync("./");
```

![20211113235512](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211113235512.png)

**注解**

上面这段代码大致逻辑：__importDefault 是一个辅助函数，该函数的返回值要么是 require("fs") 要么是 { default: require("fs") }，由于现在是不会报错的，所以返回的必然是后者。其它部分，看不懂就看不懂吧，只要知道这么写是不会报错的即可。

### [noEmitOnError](https://www.typescriptlang.org/tsconfig#noEmitOnError)

错误时不生成编译结果。

```ts
let str: string = 123; // => ×
```

虽然上述代码在 ts 中是会报错的。但是，类型约束并不会生成到 js 中，所以在 js 中，是不会报错的。默认情况下，依旧可以对该 ts 文件进行编译，编译生成的 js 文件的内容如下：

```js
let str = 123;
```

若我们想让 ts 在报错的情况下，无法进行编译，那么需要配置 onEmitOnError 字段：

```json
{
  "compilerOptions": {
    "noEmitOnError": true,
  },
}
```