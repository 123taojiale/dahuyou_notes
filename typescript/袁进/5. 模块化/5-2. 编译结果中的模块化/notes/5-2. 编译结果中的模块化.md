## 5-2. 编译结果中的模块化

### 前言

- 时长：17min

**Q**

- [ ] 编译结果中的模块化标准，是否是可配置的？
- [ ] tsc --watch 这个命令有什么用？
- [ ] tsc --watch 会执行编译结果嘛？
- [ ] 默认情况下，ts 中的注释，是否会生成到编译结果中？
- [ ] 如何配置 tsconfig.json 文件，让编译时，忽略我们写的注释？

> **A**
>
> - 编译结果中的模块化标准，可以配置为 es6 module、commonjs 等等，但是最常用的就是这两个，并且我们也只需要掌握好这两个即可；
>   需要配置 tsconfig.json 中的 module 字段；
> - 当我们编写的 ts 文件发生变化时，它会帮我们自动进行编译，生成对应的 js 文件；
> - 不会；
> - 会；
> - 在 compilerOptions 中添加配置 `removeComments: true;`；
> 

### 可配置

编译结果中的模块化代码，是可以配置的。

```json
{
  "compilerOptions": {
    "target": "xxx", // => 该字段用于配置我们在 ts 文件中写的模块化标准
    "module": "xxx", // => 该字段用于配置编译结果的模块化标准
  },
}
```

### --watch

`tsc --watch`

使用该命令，用于监听 ts 文件的变化，一旦文件内容发生了变化，那么就会重新编译。（只编译，不运行）

### target -> es6、module -> es6

先给出结论，当 target 和 module 配置的都是 es6 module 标注时，生成的编译结果和我们写的 ts 文件，模块化部分是保持不变的。

tsconfig

```json
{
  "compilerOptions": {
    "target": "es6",
    "module": "es6",
    "lib": [
      "es2016"
    ],
    "outDir": "./dist",
    "strictNullChecks": true
  },
  "include": [
    "./src"
  ],
}
```

index.ts

```ts
import { nickname, sum } from "./myModule";
console.log(nickname); // => dahuyou
console.log(sum(1, 2)); // => 3
```

myModule.ts

```ts
export const nickname = "dahuyou";
export function sum(a: number, b: number) {
  return a + b;
}
```

index.js

```js
import { nickname, sum } from "./myModule";
console.log(nickname); // => dahuyou
console.log(sum(1, 2)); // => 3
```

myModule.js

```js
export const nickname = "dahuyou";
export function sum(a, b) {
  return a + b;
}
```

### removeComments

从上面的编译结果中可以看出，我们在 ts 中编写的相关注释，也是会生成到编译结果中的。若我们想要去掉注释，只需要加上一个配置 removeComments，将其值设置为 true 即可。

```json
{
  "compilerOptions": {
    "removeComments": true
  },
}
```

### target -> es6、module -> commonjs

tsconfig

```json
{
  "compilerOptions": {
    "target": "es6",
    "module": "commonjs",
    "lib": [
      "es2016"
    ],
    "outDir": "./dist",
    "strictNullChecks": true,
    "removeComments": true
  },
  "include": [
    "./src"
  ],
}
```

index.ts

```ts
import sayHello, { nickname, sum } from "./myModule";
console.log(nickname); // => dahuyou
console.log(sum(1, 2)); // => 3
sayHello(); // => hello world.
```

myModule.ts

```ts
export const nickname = "dahuyou";
export function sum(a: number, b: number) {
  return a + b;
}
export default () => {
  console.log("hello world.");
};
```

index.js

```js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const myModule_1 = require("./myModule");
console.log(myModule_1.nickname);
console.log((0, myModule_1.sum)(1, 2));
(0, myModule_1.default)();
```

myModule.js

```js
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.sum = exports.nickname = void 0;
exports.nickname = "dahuyou";
function sum(a, b) {
    return a + b;
}
exports.sum = sum;
exports.default = () => {
  console.log("hello world.");
};
```

#### noImplicitUseStrict

生成的编译结果 index.js 和 myModule.js 的首行，都加上了 `"use strict"` 严格模式。但是，这句话其实是没有必要的，因为我们写的 ts 代码，比严格模式的限制要多得多，所以不加这行也是 OK 的。

若想去掉编译结果中生成的 `"use strict"`，那么需要配置 noImplicitUseStrict。

```json
{
  "compilerOptions": {
    "noImplicitUseStrict": true
  },
}
```


#### 编译结果分析

- `Object.defineProperty(exports, "__esModule", { value: true });`
  等效于：`exports.__esModule = true;`
- `exports.sum = exports.nickname = void 0;`
  等效于：`exports.sum = undefined; exports.nickname = undefined;`
  参考文章：[sf => 谈谈 Javascript 中的 viod 操作符](https://segmentfault.com/a/1190000000474941)
- `exports.default = () => { console.log("hello world."); }`
  es6 的默认导出，转为 commonjs 后，会转为 exports 的 default 属性。
- `(0, myModule_1.sum)(1, 2)`、`(0, myModule_1.default)()`
  等效于：`myModule_1.sum(1, 2)`、`myModule_1.default()`
  参考文章：[stack overflow => What is the meaning of this code (0, function) in javascript [duplicate]](https://stackoverflow.com/questions/40967162/what-is-the-meaning-of-this-code-0-function-in-javascript)

