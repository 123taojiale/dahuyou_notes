# 3. 基本类型检查 {ignore}

[toc]

## 3-1. 类型约束和编译结果对比

### 前言

- 时长：19min

### 类型约束

一般仅会对以下内容进行约束：
- **变量**
- **函数参数**
- 函数返回值

> 通常，我们只要对函数参数和变量进行约束即可。函数的返回值会根据我们对函数参数、变量的约束，自行推导（类型推导）出来。

Syntax：`:类型名称`

```ts
let nickName:string;
nickName = "xxx";
// nickName = 123; // => 会报错
```

```ts
function sum(a:number, b:number):number {
  return a + b;
}
```

类型推导：根据我们所写的代码，自动完成类型检查。

```ts
function sum(a:number, b:number) {
  return a + b;
}
/*
对于上面那种写法，我们可以省略到对函数返回值的类型约束。
因为，根据我们对参数 a、b 的约束，它们都是数字，返回的是它们相加的结果，必然也是一个数字。
ts 可以识别出返回值的类型必然是一个数字，所以我们可以省略对函数返回值的类型约束 => 类型推导。
*/
```

![20211109154810](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211109154810.png)

#### 补充

- F2：一次性重命名
- F12：快速跳转到函数的声明位置

![20211109155450](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211109155450.png)

- 判断是否有类型约束：在 vscode 编辑器中，看变量左下角是否有三个点。

![20211109160211](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211109160211.png)

> any 表示任意类型，对该类型，ts 不进行类型检查。

- 电话号码，应该是一个字符串类型还是数字类型？

![20211109160217](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211109160217.png)

```ts
let phone = "11122223333";
```

答：电话号码应该是一个字符串类型。判断的依据是看如何“读”。若读作：“一百一十一亿二千二百二十二万三千三百三十三”，那么就应该使用数字类型；若是一个数字一个数字的读，那么就应该使用字符串类型。同理：学号、工号，等等。都应该是字符串类型。


### 编译结果对比

执行命令 `tsc`，对比编译后生成的 js 文件和我们写的 ts 文件的差异：

![20211109161119](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211109161119.png)

会发现只有类型约束没了，其他的内容完全没变。

## 3-2. 基本类型

### 前言

- 时长：13min

### 基本类型

- number：`:number`
- string：`:string`
- boolean：`:boolean`
- object：`:object`
- array：`:number[]`、`:Array<number>`
- null：`:null`
- undefined：`:undefined`
- any：`:any`

null 和 undefined 是所有其他类型的子类型，它们可以赋值给其他类型。通过添加 `strictNullChecks:true`，可以获得更严格的空类型检查，null 和 undefined 只能赋值给自身。

### codes

- [ ] 1.ts

```ts
// 封装 boolean 函数，当我们写到下面这一步时，boolean 会有警告。
// 因为我们还没有开始写函数体，没有指定函数的返回值。
function isOdd(n: number): boolean { }
// 其声明类型不为 "void" 或 "any" 的函数必须返回值。
```

```ts
// 当我们写到这一步时，就不会有报错了
function isOdd(n: number): boolean {
  return n % 2 === 0;
}
```

```ts
// 返回值也可以不进行约束，ts 会智能地进行类型推导，它能够识别出表达式 n % 2 === 0 的结果必然是一个 boolean 类型。
function isOdd(n: number) {
  return n % 2 === 0;
}
```

![20211111141040](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111141040.png)

如上图所示，ts 会自动识别出函数 isOdd 的返回值是 boolean 类型，所以我们可以直接省略对其返回值的类型声明。其实，在很多情况下，ts 都能够帮我们完成类型推导。

> 类型推导是否成功，在前面介绍过，就是看变量名左下角是否有三个小点。
> 类型推导的结果，我们也可以查看，方式也很简单，直接将鼠标悬停在变量名上边即可。

- [ ] 2.ts

```ts
let nums_1: number[] = [1, 2, 3];

let nums_2: Array<number> = [1, 2, 3];
/*
number[] 是 Array<number> 的语法糖，它们俩是等效的。
表示的含义是：要求数组的每一项都是数字类型。
推荐使用第一种写法：number[]
*/
```

```ts
let nums = [1, 2, 3];
/*
我们也可以直接这么写，ts 会帮我们完成类型推导。
将鼠标悬停在 nums 上，会提示：“let nums: number[]”，表示 nums 是一个数字数组，nums 的每一个成员都是数字类型。
所以说，我们平时在写 ts 时，虽然还是用原来写 js 的习惯来写，但是代码的质量就会比之前要高很多，它能帮我们规避一些不必要的问题。
*/
```

- [ ] 3.ts

```ts
let user: object = {
  name: "dahuyou",
  age: 22,
};
/*
object 虽然也具有一定的限制作用，但是，它的限制作用不强。
它只能限制我们给 user 变量赋值时必须赋一个对象，但是无法限制对象里面每个成员具体是什么类型。
所以，我们一般很少会使用它。
*/
```

- [ ] 4.ts

```ts
function printObj(obj: object) {
  const vals = Object.values(obj);
  vals.forEach((v) => console.log(v));
}

printObj({
  name: "dahuyou",
  age: 22,
});
```

- [ ] 5.ts

```ts
let str: string = undefined;
/*
null 和 undefined 是所有其他类型的子类型，它们可以赋值给其他类型。
但是，在开启 "strictNullChecks": true 的情况下，会报错：不能将类型“undefined”分配给类型“string”。
*/
```

上面这种写法，并不会报错，因为 undefined 会被识别为 string 的子类型，上面这种赋值的方式是被允许的。但是，这样的操作往往是我们不希望看到的，我们可以通过在配置中添加 `strictNullChecks:true`，以获得更严格的空类型检查，使得 null 和 undefined 只能赋值给自身。

```json
{
  "compilerOptions": {
    "target": "es2016",
    "module": "commonjs",
    "lib": [
      "es2016"
    ],
    "outDir": "./dist",
    "strictNullChecks": true
  },
  "include": [
    "./src"
  ],
}
```

**Attention**：strictNullChecks 要写在 compilerOptions 下边，它是编译的配置项。

## 3-3. 其它类型

### 前言

- 时长：19min

### 其它类型

除了上节介绍的基本类型外，ts 还给我们提供了一些其它常用的类型：

- 联合类型：多种类型任选其一；
- viod 类型：通常用于约束函数的返回值，表示函数没有任何返回；
- never 类型：通常用于约束函数的返回值，表示该函数永远不可能结束；
- 字面量类型：使用一个值进行约束；
- 元祖类型（Tuple）：一个固定长度的数组，并且数组中的每一项的类型确定；
- any 类型：any 类型可以绕过类型检查，因此，any 类型的数据可以赋值给任意类型；

### 类型保护

类型保护：当对某个变量进行类型判断之后，在判断的语句块中便可以确定它的确切类型，typeof 可以触发类型保护。

联合类型可以配合类型保护进行判断。

> 类型保护的触发方式有很多种，后边会有对应的课程专门介绍，通常我们会使用 typeof 来触发简单类型（number、string、boolean 等）的类型保护。

### codes

- [ ] 1.ts

```js
let foo: string | number[] = [1, 2, 3];
/*
foo 可以是 string 类型，也可以是 number[] 类型。
*/
```

- [ ] 2.ts

```ts
let foo: string | number[];

foo; // => string | number[]

// 类型保护
if (typeof foo === "string") {
  foo; // => string
  foo = foo.toUpperCase();
} else {
  foo; // => number[]
  foo.forEach((v) => console.log(v));
}
/*
联合类型配合类型保护，可以明确变量 foo 具体是什么类型。
当 ts 能够明确某个变量具体是什么类型时，我们在调用它身上的一些方法时，都会有精准的智能提示。
*/
```

![20211111154054](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111154054.png)

补充：

![20211111155545](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111155545.png)

- [ ] 3.ts

```ts
function printMenu() { // function printMenu(): void
  console.log("1. login");
  console.log("2. singn up");
}
```

- [ ] 4.ts

```ts
function throwError(msg: string): never {
  throw new Error(msg);
  console.log("123"); // 永远不会执行
}
/*
若我们不指定 throwError 函数的返回值，那么它推断出来的结果是：
  function throwError(msg: string): void
在这种情况下，我们就需要手动约束，指定其返回值为 never，表示该函数永远不可能结束。
*/
```

- [ ] 5.ts

```ts
function alwaysDoSomething(): never {
  while (true) {
    // ...
  }
}
/*
若不进行约束，那么识别出函数的返回值为 void
  function alwaysDoSomething(): void
此时，也需要我们进行手动约束。
*/
```

- [ ] 6.ts

```ts
let gender: "male" | "female";
gender = "male";
/*
字面量约束，是一种很强力的约束，我们只能从指定的字面量中选值。
*/
```

![20211111160520](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111160520.png)

```ts
let arr: []; // 这也是一个字面量约束，表示 arr 只能赋值为一个空数组。
```

- [ ] 7.ts

```ts
// 对象的字面量约束（注意语法）
let user: {
  name: string;
  age: number;
};

user = {
  name: "dahuyou",
  age: 22,
};
/*
对象也可以有字面量约束。
上述代码约束 user 对象需要具有两个属性：name，age；
并且：name 必须是 string 类型，age 必须是 number 类型；
*/
```

> 我们一般不会使用上面这种写法来对一个对象进行约束，在学习了后边的知识后，我们一般会采用“接口”、“类”、“类型别名”。。。来对对象类型的数据进行约束。

- [ ] 8.ts

```ts
let tuple: [number, string];
tuple = [1, "1"];
/*
元祖类型（Tuple）：一个固定长度的数组，并且数组中的每一项的类型确定；
要求 tuple 必须是一个数组，该数组必须有两项，第一项必须是 number 类型、第二项必须是 string 类型。
*/
```

- [ ] 9.ts

```ts
let data:any = "123";
let num:number = data;
/*
any 类型：any 类型可以绕过类型检查，因此，any 类型的数据可以赋值给任意类型；
上述代码不会报错，但是，我们往往不希望有这样的行为，所以 any 类型，非必要的情况下，最好不要使用。
*/
```

## 3-4. 类型别名

### 前言

- 时长：5min

### 类型别名

对已知的一些类型定义名称。

```ts
type 类型名 = ...
```

类型别名并不会生成到编译结果中。

### codes

- [ ] 1.ts

```ts
// 用户对象的类型约束
let u: {
  name: string;
  age: number;
  gender: "male" | "female";
};

// 获取用户对象
function getUsers(): {
  name: string;
  age: number;
  gender: "male" | "female";
}[] {
  return [];
}
/*
获取用户对象的方法，返回的是一个数组，数组的每一项都是一个 u。
使用上面这种写法，当然也可以实现效果，但是，这么写很不好，存在的主要问题有：
1. 读性差；
2. 不易维护；
   若用户对象的类型约束（对象结构）发生了变化，那么需要改动的地方很多；
   咋们写代码讲究：高内聚、低耦合。
*/
```

```js
// 编译结果
let u;
function getUsers() {
  return [];
}
```

- [ ] 2.ts

```ts
type Gender = "male" | "female";
type User = {
  name: string;
  age: number;
  gender: Gender;
};

let u: User;

function getUsers(g: Gender): User[] {
  return [];
}
/*
使用 type 来定义类型别名，直接看代码，很好理解。
*/
```

![20211111165114](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111165114.png)

```js
// 编译结果
let u;
function getUsers(g) {
  return [];
}
```

## 3-5. 函数的相关约束

### 前言

- 时长：15min

### 函数重载

函数重载：在函数实现之前，对函数调用的多种情况进行声明。不会生成到编辑结果中。

### 可选参数

可选参数：可以在某些参数名后加上问号，表示该参数可以不用传递。不会生成到编辑结果中。

**Attention**：可选参数必须在参数列表的末尾。

### codes

- [ ] 1.ts

```ts
function combine(a: number, b: number): number;
function combine(a: string, b: string): string;
function combine(a: number | string, b: number | string): number | string {
  if (typeof a === "number" && typeof b === "number") {
    return a * b;
  } else if (typeof a === "string" && typeof b === "string") {
    return a + b;
  }
  throw new Error("a 和 b 必须是相同的类型");
}

combine(1, 2); // => 2
combine("1", "2"); // => 12
// combine(1, '2');
```

![20211111170945](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111170945.png)

当我们写了函数重载后，再去调用函数，就会有智能提示：

![20211111172030](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111172030.png)

我们还可以给每个重载添加上注释，这样我们在调用函数的时候，我们写的相关注释内容，也会显示出来。

```ts
/**
 * 得到 a 和 b 相乘的结果
 * @param a
 * @param b
 */
function combine(a: number, b: number): number;
/**
 * 得到 a 和 b 拼接的结果
 * @param a
 * @param b
 */
function combine(a: string, b: string): string;
// ...
```

![20211111173112](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211111173112.png)

- [ ] 2.ts

```ts
function sum(a: number, b: number, c?: number) {
  if (c) return a + b + c;
  return a + b;
}

sum(1, 2); // => 3
sum(1, 2, 3); // => 6
/*
可选参数，表示该参数可以不传递。
在冒号前面加上一个问号，表示该参数是可选的 ?:
c 就是可选参数，它可能是 undefined 或 number。
*/
```

- [ ] 3.ts

```ts
function sum_3(a: number, b: number, c: number = 3) {
  if (c) return a + b + c;
  return a + b;
}

sum_3(1, 2); // => 6
/*
默认参数，写法上和 es6 的默认参数写法相同。
默认参数表示当我们没有传递这个参数时，该参数的值是什么。由此可知，默认参数必然是可选的。
类型推断的结果：function sum_3(a: number, b: number, c?: number): number
从类型推断的结果中我们发现，c 被识别为一个可选参数。
*/
```

```ts
function test(a: number, b: number, c?: number) {}
function test(a: number, b?: number, c?: number) {}
function test(a?: number, b?: number, c?: number) {}
/*
因为我们在调用函数的时候，参数都是挨个传递的，不可能说我们传递了第二个参数，而没有传递第一个参数。
结论：
  可选参数可以有多个，但是一定要出现在末尾。
  若一个参数是可选的，那么后续参数必然也是可选的。
*/
```

## 3-6. 练习：创建并打印扑克牌

### 前言

- 时长：16min

打印扑克，忽略大小王。

### codes

- [ ] pocker.practice.ts

```js
type Color = "♥" | "♠" | "♦" | "♣"; // 扑克花色
type NormalCard = {
  // 一张牌
  color: Color;
  mark: number;
};
type Deck = NormalCard[]; // 一副牌

function createDeck(): Deck {
  const deck: Deck = [];
  for (let i = 1; i <= 13; i++) {
    deck.push(
      {
        mark: i,
        color: "♠",
      },
      {
        mark: i,
        color: "♣",
      },
      {
        mark: i,
        color: "♥",
      },
      {
        mark: i,
        color: "♦",
      }
    );
  }
  return deck;
}

function printDeck(deck: Deck) {
  let result = "";
  deck.sort(() => Math.random() - 0.5); // 乱序
  deck.forEach((pocker, i) => {
    const num = pocker.mark;
    if (num <= 10) {
      result += num + pocker.color + " ";
    } else if (num === 11) {
      result += "J" + pocker.color + " ";
    } else if (num === 12) {
      result += "Q" + pocker.color + " ";
    } else if (num === 13) {
      result += "K" + pocker.color + " ";
    }
    // 每打印 17 张牌，换行。
    if ((i + 1) % 17 === 0) {
      result += "\n";
    }
  });
  console.log(result);
}

const deck = createDeck();
printDeck(deck);
```