# 4. 扩展类型 - 枚举 {ignore}

[toc]

## 4-1. 字面量类型的问题

### 前言

- 时长：11min

认识某些场景下，若我们要限定变量的取值范围时，不使用枚举式写法所带来的一些问题。

### 扩展类型

扩展类型就是我们自己定义的一些类型：
- 类型别名
- 枚举
- 接口
- 类

### 枚举

我们本节课要学习的“枚举”，通常用于约束某个变量的取值范围。

虽然，我们前面所学习的“字面量”和“联合类型”配合使用，也可以达到同样的效果。但是，它们还存在一些问题，这些问题就是本节课要介绍的点。



### 问题

- 在类型约束位置，会产生重复代码。
- 逻辑含义和真实的值产生了混淆，会导致当修改真实值的时候，产生大量的修改。
- 字面量类型不会进入到编译结果。

对于第一个有关重复代码的问题，可以使用类型别名来解决。但是，另外两个问题，使用类型别名就没法解决了。

> 上面提到的这些问题，都将在 codes 部分，以代码的形式来呈现。问题具体如何解决，会在 3-2 中介绍。

### codes

- [ ] 1.ts

```ts
let gender: "male" | "female";

gender = "male";

function searchUsers(g: "male" | "female") {}
/*
使用字面量类型，会在类型约束的位置产生大量的重复代码。
对于该问题，我们可以使用之前学习到的类型别名来解决。
*/
```

- [ ] 2.ts

```ts
type Gender = "male" | "female";

let gender: Gender;

gender = "male";

function searchUsers(g: Gender) {}
/*
使用类型别名解决在类型约束位置产生的重复代码问题。
*/
```

- [ ] 3.ts

我们知道，对于性别，无非就是“男 | 女”。但是，我们显示给用户看的真实的值，可就不一定是“男 | 女”了，也可以是“先生 | 女士”、“帅哥 | 美女”、“boy | girl”、“male | female”等等。

那么就会有这样一种情况，倘若有一天，我们需要修改展示给用户看的值，那么我们需要修改的地方就会很多，工作量就会很大，而且容易出错。而我们希望的是，只要修改类型约束部分，修改一个地方就可以完成所有的修改。对于这样的需求，使用原来的字面量式写法，显然就无法解决了。使用枚举，就可以很好地解决这样的问题。

```ts
type Gender = "男" | "女";

let gender: Gender;

gender = "男";

function searchUsers(g: Gender) {}
```

![20211112110310](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211112110310.png)

当我们修改完 1 后，还得修改 2。虽然在个案例中看不出有什么大问题，但是，试想一下，若程序的规模很大，很多地方都用到了 Gender 类型，那我们需要修改的量，可就不是上边这么一丢丢了。

```js
// 编译结果
let gender;
gender = "男";
function searchUsers(g) { }
```

从编译结果中，我们可以看出，类型别名是不会生成到最终的结果中的。若我们在编辑结果中想要获取到 gender 所有可能的值，也就是 Gender 中限定的值，那么使用上面这种类型别名的写法，也是无法获取到的。

## 4-2. 枚举的使用

### 前言

- 时长：20min

学习约束某个变量的取值范围的最佳实践 - 使用枚举。

### Syntax

```ts
enum 枚举名 {
  枚举字段1 = 值1,
  枚举字段2 = 值2,
  ...
}
```

### Attention

- 枚举会出现在编译结果中，编译结果中表现为一个对象；
- 枚举的字段值可以是字符串或数字；
- 数字枚举的值会自动自增；
- 被数字枚举约束的变量，可以直接赋值为数字；
- 数字枚举的编译结果和字符串枚举有差异；


### Best Practices

- 尽量不要在一个枚举中，即出现字符串字段，又出现数字字段；
- 使用枚举式，尽量使用枚举字段的名称，而不使用真实的值；

### codes

- [ ] 1.ts

```ts
enum Gender {
  male = "男",
  female = "女",
}

let gender: Gender;

gender = Gender.male;

function searchUsers(g: Gender) {}
/*
枚举的写法
male 和 female 是逻辑名称，它们映射的值，是真实展示给用户看的值。
我们在写的时候，写的是逻辑名称，比如：Gender.male 但是读取到的，是真实的值。
*/
```

**认识一下枚举的图标**

![20211112113007](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211112113007.png)

**一键重命名**

我们通常遇到的需求，修改的都是展示给用户看的值，一般不会有需求是改变逻辑含义的。但是，若我们需要修改逻辑名，也是可以一键修改的，在指定的逻辑名上右键，选择重命名符号即可修改。（或直接按 F2）

![20211112120059](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20211112120059.png)

**编译结果分析**

```js
// 编译结果
var Gender;
(function (Gender) {
    Gender["Male"] = "\u7537";
    Gender["female"] = "\u5973";
})(Gender || (Gender = {}));
let gender;
gender = Gender.Male;
function searchUsers(g) { }
```

在编译结果中，枚举 Gender 会被识别为一个对象。

> 由于我们使用到了中文，会进行 Unicode 编码：
> - “男” 对应的 Unicode 编码是 \u7537
> - “女” 对应的 Unicode 编码是 \u5973

```js
var Gender;
(function (Gender) {
    Gender["Male"] = "\u7537";
    Gender["female"] = "\u5973";
})(Gender || (Gender = {}));
// 等价于：
var Gender {
  Male: "男",
  female: "女"
}
```

- [ ] 2.ts

```ts
enum Gender {
  Male = "男",
  female = "女",
}

function printGenders() {
  const vals = Object.values(Gender);
  vals.forEach((v) => console.log(v));
}
printGenders();
```

在编译结果中，我们也可以获取到 Gender 中定义的真实值。

- [ ] 3.ts

```ts
enum Level {
  level1 = 1,
  level2 = 2,
  level3 = 3,
}

let l: Level = Level.level1;
l = Level.level2;
/*
枚举的字段值可以是字符串或数字；
*/
```

编译结果分析

```js
// 编译结果
var Level;
(function (Level) {
    Level[Level["level1"] = 1] = "level1";
    Level[Level["level2"] = 2] = "level2";
    Level[Level["level3"] = 3] = "level3";
})(Level || (Level = {}));
let l = Level.level1;
l = Level.level2;
```

数字枚举的编译结果和字符串枚举是有差异的：

```js
(function (Level) {
    Level[Level["level1"] = 1] = "level1";
    Level[Level["level2"] = 2] = "level2";
    Level[Level["level3"] = 3] = "level3";
})(Level || (Level = {}));
// 相当于生成了下面这样一个对象
{
  level1: 1,
  level2: 2,
  level3: 3,
  "1": "level1",
  "2": "level2",
  "3": "level3",
}
```

- [ ] 4.ts

```ts
enum Level {
  level1 = 1,
  level2, // 相当于写了 level2 = 2,
  level3, // 相当于写了 level3 = 3,
}

let l: Level = Level.level1;
l = Level.level2;
/*
数字枚举的值会自动自增；
这种 4.ts 中的代码，和 3.ts 中的代码，是完全等效的。
*/
```

**枚举字段值都为空**

若枚举字段的值，都没有填写，那么默认是数字枚举，并且起始字段的值为 0。

```ts
enum Level {
  level1, // 相当于写了 level2 = 0,
  level2, // 相当于写了 level2 = 1,
  level3, // 相当于写了 level3 = 2,
}
```

- [ ] 5.ts

```ts
enum Level {
  level1,
  level2,
  level3,
}

let lev: Level = 1; // 不会报错
lev = 2; // 不会报错
/*
被数字枚举约束的变量，可以直接赋值为数字；
但是，不推荐这么写。
*/
```

## 4-3. 练习：使用枚举优化扑克牌程序

### 前言

- 时长：10min

### codes

- [ ] pocker.practice.ts

```ts
enum Color {
  heart = "♥",
  spade = "♠",
  club = "♣",
  diamond = "♦",
}

enum Mark {
  A = "A",
  two = "2",
  three = "3",
  four = "4",
  five = "5",
  six = "6",
  seven = "7",
  eight = "8",
  nine = "9",
  ten = "10",
  jack = "J",
  queen = "Q",
  king = "K",
}

type NormalCard = {
  // 一张牌
  color: Color;
  mark: Mark;
};

type Deck = NormalCard[]; // 一副牌

function createDeck(): Deck {
  const deck: Deck = [];
  const marks = Object.keys(Mark);
  const colors = Object.keys(Color);
  for (const m of marks) {
    for (const c of colors) {
      deck.push({
        mark: Mark[m],
        color: Color[c],
      });
    }
  }
  return deck;
}

function printDeck(deck: Deck) {
  let result = "";
  deck.sort(() => Math.random() - 0.5); // 乱序
  deck.forEach((pocker, i) => {
    result += pocker.color + pocker.mark + " ";
    if ((i + 1) % 17 === 0) {
      result += "\n";
    }
  });
  console.log(result);
}

const deck = createDeck();
printDeck(deck);
```

## 4-4. 扩展知识：枚举的位运算

### 前言

- 时长：18min

扩展内容暂且不看。。。