# JSX

## 什么是JSX

- Facebook起草的JS扩展语法
- 本质是一个JS对象，会被babel编译，最终会被转换为React.createElement
- 每个JSX表达式，有且仅有一个根节点
  - React.Fragment
- 每个JSX元素必须结束（XML规范）

## 在JSX中嵌入表达式

- 在JSX中使用注释
- 将表达式作为内容的一部分
  - null、undefined、false不会显示
  - 普通对象，不可以作为子元素
  - 可以放置React元素对象
- 将表达式作为元素属性
- 属性使用小驼峰命名法
- 防止注入攻击
  - 自动编码
  - dangerouslySetInnerHTML

## 元素的不可变性

- 虽然JSX元素是一个对象，但是该对象中的所有属性不可更改
- 如果确实需要更改元素的属性，需要重新创建JSX元素


# 截图

## 什么是JSX

![](截图/2022-04-13_15:02:43.png)

![](截图/2022-04-13_15:03:00.png)

![](截图/2022-04-13_15:05:01.png)



![](截图/2022-04-13_15:05:14.png)

如果我们写的 JSX 表达式没有结束标记，那么是会报错的。

![](截图/2022-04-13_15:05:23.png)

没有结束的 JSX 表达式。

标签结束的写法可以是：
自结束：`<img />`
结束标签：`<img></img>`

速写：`img/` 加 tab 键，快速生成 `<img alt="" src="" />`

## 在JSX中嵌入表达式

![](截图/2022-04-13_15:30:08.png)

等效写法

![](截图/2022-04-13_15:38:30.png)

![](截图/2022-04-13_16:10:22.png)

![](截图/2022-04-13_16:10:36.png)

如果表达式结果是 null、undefined、false，那么将不会显示在界面上。但是，元素依旧会生成。

如果要在界面中展示 null，并且它是在表达式中的，那么我们可以将其强行转为字符串展示。

![](截图/2022-04-13_16:12:52.png)

![](截图/2022-04-13_16:13:27.png)

![](截图/2022-04-13_16:59:48.png)

false 不显示，并不是说隐式转换为 false 的值也不显示。

![](截图/2022-04-13_17:01:27.png)

**插入的是对象**
不允许插入的是一个普通的 js 对象
允许插入的是一个 react 元素对象

`const obj = <span>这是一个 react 元素对象</span>`
`const obj = { name: "这是一个普通对象" }`

![](截图/2022-04-13_17:07:22.png)

插入的是一个数组，那么会取出数组中的每一项，插入到页面中。

如果插入的数组成员中含有 react 元素对象，记得绑定 key 值。

![](截图/2022-04-13_17:12:09.png)

`src={url}`
如果属性值来自与一个变量，此时就需要动态绑定属性值，语法上依旧是通过一对大括号来表示

`class`、`className`
冲突问题：一些 html 元素属性名和 js 中的关键字之间的冲突。
比如 class：
在 js 语法中，它是用于声明类的关键字；
在 html 的元素身上，它表示 class 属性；

![](截图/2022-04-13_17:16:13.png)

![](截图/2022-04-13_17:17:20.png)

准备好 index.css 样式文件，然后将其导入到工程中。

![](截图/2022-04-13_17:18:05.png)

![](截图/2022-04-13_17:19:26.png)

style 属性绑定的属性值，要求是一个对象类型
这里用到了两个大括号，注意要区分开它们
外层：语法要求，该括号里面的内容是普通的 js 表达式
内层：这是对象字面量写法，就是普通的 js 表达式

样式名称的命名，可以采用小驼峰命名法来命名，这么写 react 是可以识别的。

![](截图/2022-04-13_17:23:06.png)

![](截图/2022-04-13_17:22:54.png)

插入动态的文本内容时，会将其原样输出
效果就相当于是给元素的 innerText 属性赋值

![](截图/2022-04-13_17:24:16.png)

打开控制台，选中 #root 元素，然后右键，选择 edit as html

查看编码后的结果

这个编码后的结果，就是 react 处理后插入到页面中的真实内容。

这么做的目的是为了防止注入攻击

但是有些时候，我们如果能够确保插入的内容是安全的，并且我们希望将插入的内容视作正常的 html 来插入，那么可以使用：`dangerouslySetInnerHTML`

就相当于给元素的 innerHTML 属性重新赋值

![](截图/2022-04-13_17:28:03.png)

![](截图/2022-04-13_17:28:42.png)

## 元素的不可变性

不要尝试去操作 react 元素对象身上的属性

![](截图/2022-04-13_17:30:17.png)

![](截图/2022-04-13_17:30:40.png)

![](截图/2022-04-13_17:31:58.png)

因为我们创建的 react 元素对象默认是被冻结的

由此可知，在 react 元素被创建出来之后，它是不可变的

如果我们需要在页面中看到一个变动值的效果，那么需要重新渲染，如下：

![](截图/2022-04-13_17:32:57.png)

![](截图/2022-04-13_17:35:32.png)

看似上述操作效率会很低，每次都要先将之前的真实 DOM 移除，然后插入新的 DOM 元素。

实际上并不是这样的，react 元素对象发生变化后，react 会先比较发生变动的元素，然后找到变化的部分，再去更新真实 DOM。涉及到真实 DOM 的操作会尽可能的减少。





</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>
</br>