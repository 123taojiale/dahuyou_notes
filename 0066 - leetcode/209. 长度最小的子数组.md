链接：[https://leetcode.cn/problems/minimum-size-subarray-sum](https://leetcode.cn/problems/minimum-size-subarray-sum)

## 题解1 滑动窗口

```javascript
/**
 * 22-09-12
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  const len = nums.length

  let i = j = 0, sum = nums[j], ans = 0

  while (j < len) {
    // console.log(sum)
    if (sum >= target) {
      if (ans === 0) ans = j - i + 1
      else ans = Math.min(ans, j - i + 1)

      sum -= nums[i]
      i++
    } else {
      j++
      if (j === len) continue
      sum += nums[j]
    } 
  }

  return ans
}
```
![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1662943122779-e6704eee-33f9-408b-87d9-5549002eee0a.png#clientId=uc225dc72-c524-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=122&id=u9f8917ed&margin=%5Bobject%20Object%5D&name=image.png&originHeight=244&originWidth=902&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48786&status=error&style=stroke&taskId=u0c7d1c8f-a0e6-4941-a5d4-fd77becac6f&title=&width=451)

- 扩展窗口：`j++` `sum += nums[j]`
- 收缩窗口：`sum -= nums[i]` `i++`

```javascript
/**
 * 22-10-07
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  nums.push(0)
  const len = nums.length

  let i = j = 0, sum = nums[j], minLen = 0

  while (j < len) {
    if (sum >= target) {
      if (minLen === 0) minLen = j - i + 1
      else minLen = Math.min(minLen, j - i + 1)

      sum -= nums[i++]
    } else {
      sum += nums[++j]
    }
  }

  return minLen
}
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1665102053453-4d0bb364-5bb7-420f-beb6-56dfc1852cd8.png#clientId=ucf1be46c-6403-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=121&id=u18be2fdb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=838&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47940&status=done&style=stroke&taskId=ufcf37dbf-ee92-4d3f-99e5-bf25acacc06&title=&width=419)

- 扩展窗口：`sum += nums[++j]`
- 收缩窗口：`sum -= nums[i--]`

```javascript
/**
 * 22-09-13
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  if (nums.reduce((a, b) => a + b, 0) < target) return 0

  const len = nums.length

  let i = 0, j = -1, total = 0, ans = len + 1

  while (i <= len - 1) {
    if (j + 1 < len && total < target) {
      j++
      total += nums[j]
    } else {
      total -= nums[i]
      i++
    }

    if (total >= target) {
      ans = Math.min(ans, j - i + 1)
    }
  }
  if (ans === len + 1) {
    return 0
  }
  return ans
};
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1663066663197-8944a170-bf49-470d-9955-2cd65c4df8c7.png#clientId=ua1c51aac-545d-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=126&id=uf07db7b4&margin=%5Bobject%20Object%5D&name=image.png&originHeight=252&originWidth=862&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49844&status=error&style=stroke&taskId=u6e2dc695-633c-4ca5-b924-28094a3af70&title=&width=431)

要求是连续子数组，所以我们必须定义 `i`，`j` 两个指针，`i` 向前遍历，`j` 向后遍历，相当与一个滑块，这样所有的子数组都会在 `[i...j]` 中出现，如果 `nums[i..j]` 的和小于目标值 `s`，那么 `j` 向后移一位，再次比较，直到大于目标值 `s` 之后，`i` 向前移动一位，缩小数组的长度。遍历到 `i` 到数组的最末端，就算结束了，如果不存在符合条件的就返回 `0`。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1663066713346-e67f82f3-7f88-4351-8c46-344a17c1ebb6.png#clientId=ua1c51aac-545d-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=125&id=uc448c855&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=1029&originalType=binary&ratio=1&rotation=0&showTitle=false&size=10449&status=error&style=stroke&taskId=u28b1346f-ec80-4a9e-a8b3-3cce7be4406&title=&width=514.5)

> 作者：力扣 (LeetCode)
> 链接：[https://leetcode.cn/leetbook/read/all-about-array/x9z5kr/](https://leetcode.cn/leetbook/read/all-about-array/x9z5kr/)
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。


```javascript
/**
 * 22-10-07
 * @param {number} target
 * @param {number[]} nums
 * @return {number}
 */
var minSubArrayLen = function (target, nums) {
  if (nums.reduce((a, b) => a + b, 0) < target) return 0

  const len = nums.length
  let s = 0, f = 0, sum = nums[0], minLen = len + 1

  while (f < len) {
    if (sum < target) {
      sum += nums[++f] // 扩展窗口
    } else {
      minLen = Math.min(minLen, f - s + 1) // 记录最小值
      sum -= nums[s++] // 收缩窗口
    }
  }

  if (minLen === len + 1) return 0

  return minLen
};
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1665103405763-985c7d9e-a16e-4640-a0f4-8be2234235ff.png#clientId=ucf1be46c-6403-4&crop=0&crop=0&crop=1&crop=1&from=paste&height=121&id=u60ac6f6d&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=882&originalType=binary&ratio=1&rotation=0&showTitle=false&size=49380&status=done&style=stroke&taskId=u967cbecc-37ab-40d1-bf56-1a01081e918&title=&width=441)

## 小结

需要注意的点：边界的处理，主要是末尾成员的处理。

- 改造源数据：给数组的结尾添加一个不影响循环逻辑的成员，比如 0

对于返回结果的初始化，也是有一点小技巧的，因为要返回的是最小值，如果初始化为 0，那么后续处理起来会比较麻烦。不如将其设置为数组长度 + 1，如果循环结束，它的值依旧没变，说明在查找过程中，没能找到符合条件的区间，导致它没能被重新赋值，还是初始值。此时我们直接返回 0 即可。
