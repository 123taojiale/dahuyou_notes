链接：[https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted](https://leetcode.cn/problems/two-sum-ii-input-array-is-sorted)

## 题解1 暴力解法

```javascript
/**
 * 22-09-04
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (numbers, target) {
  for (let i = 0; i < numbers.length; i++)
    for (let j = i + 1; j < numbers.length; j++)
      if (numbers[i] + numbers[j] === target) return [i + 1, j + 1];
};
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1662248491732-d84eedc1-106a-47b9-862f-2290326b5579.png#clientId=udd8d7544-4312-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=123&id=u684acf13&margin=%5Bobject%20Object%5D&name=image.png&originHeight=246&originWidth=910&originalType=binary&ratio=1&rotation=0&showTitle=false&size=46963&status=error&style=stroke&taskId=ud3181592-3c5b-4eb0-9ffb-75f4931c809&title=&width=455)

![](https://cdn.nlark.com/yuque/0/2022/jpeg/2331396/1662248553769-5a3522e0-4057-40a2-a88e-e51d6200e036.jpeg)

## 题解2 二分搜索法

```javascript
/**
 * 22-09-05
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (numbers, target) {
  const len = numbers.length
  for (let i = 0; i < len; i++) {
    let low = i + 1, high = len - 1
    const item = numbers[i]
    
    while (low <= high) {
      const mid = Math.floor((high - low) / 2) + low
      
      if (numbers[mid] === target - item) return [i + 1, mid + 1]
      else if (numbers[mid] > target - item) high = mid - 1
      else low = mid + 1
    }
  }
};
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1662386221022-fdbf2c70-1f26-453a-be90-398fc80e2d9f.png#clientId=ubec3a76d-fa0a-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=121&id=u4fd99a80&margin=%5Bobject%20Object%5D&name=image.png&originHeight=242&originWidth=872&originalType=binary&ratio=1&rotation=0&showTitle=false&size=47562&status=error&style=stroke&taskId=uc648122f-663d-48a4-9c43-771331c7043&title=&width=436)

遍历每个 `nums[i]`，在剩余数组中查找 `target - nums[i]` 的值，时间复杂度为 `O(nlogn)`。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1662386302976-9bde7853-3181-46ee-bed1-e8dcff4ec6ba.png#clientId=ubec3a76d-fa0a-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=98&id=uade18e64&margin=%5Bobject%20Object%5D&name=image.png&originHeight=195&originWidth=671&originalType=binary&ratio=1&rotation=0&showTitle=false&size=16734&status=error&style=stroke&taskId=u512edf56-5259-4a31-87ba-17d47d7f5f2&title=&width=335.5)

## 题解3 对撞指针法

```javascript
/**
 * 22-09-05
 * @param {number[]} numbers
 * @param {number} target
 * @return {number[]}
 */
var twoSum = function (numbers, target) {
  const len = numbers.length
  let i = 0, j = len - 1
  while (i < j) {
    if (numbers[i] + numbers[j] === target) return [i + 1, j + 1]
    else if (numbers[i] + numbers[j] < target) i++
    else j--
  }
};
```

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1662386871263-a21c6db4-167f-47fc-94d1-398b8fc53781.png#clientId=ubec3a76d-fa0a-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=125&id=ua4596d3e&margin=%5Bobject%20Object%5D&name=image.png&originHeight=250&originWidth=896&originalType=binary&ratio=1&rotation=0&showTitle=false&size=48827&status=error&style=stroke&taskId=u602495a8-cf2c-40d2-93dc-18b7388c95d&title=&width=448)

核心逻辑：如果偏小，那就增大一些；如果偏大，那就缩小一些。

我们首先判断首尾两项的和是不是 `target`

- 如果比 `target` 小，那么我们左边取 `i + 1` 位置的数（比左边位置的数大）再和右相相加，继续判断;
- 如果比 `target` 大，那么我们右边取 `j - 1` 位置的数（比右边位置的数小）再和左相相加，继续判断；

我们通过这样不断放缩的过程，就可以在 `O(n)` 的时间复杂度内找到对应的坐标位置。

![image.png](https://cdn.nlark.com/yuque/0/2022/png/2331396/1662386341570-786a9279-e4f1-4583-b245-6f359951f58e.png#clientId=ubec3a76d-fa0a-4&crop=0&crop=0&crop=1&crop=1&errorMessage=unknown%20error&from=paste&height=92&id=ueb367bfb&margin=%5Bobject%20Object%5D&name=image.png&originHeight=184&originWidth=1012&originalType=binary&ratio=1&rotation=0&showTitle=false&size=11552&status=error&style=stroke&taskId=u9d03d017-6507-4dd2-913f-a259acffee7&title=&width=506)

其实很简答，如果头、尾之和大于目标值，那么尾左移，取一个相对小一些的值，继续求和判断；否则，头右移，取一个相对大一些的值，继续求和判断。

虽然这种做法并不能将 `numbers` 中 `i` 和 `j` 的所有排列组合都走一遍，不过一定是可以查到结果的。因为每次移动，都是以最小的步长向目标值靠拢。


## 小结


> **引用说明：**
> 
> 上述题解中，题解2、题解3，是参考官方的数组类算法中的题解写的
> 
> 作者：力扣 (LeetCode)
> 链接：[https://leetcode.cn/leetbook/read/all-about-array/x9uzh2/](https://leetcode.cn/leetbook/read/all-about-array/x9uzh2/)
> 来源：力扣（LeetCode）
> 著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

