## 1-3. Node的模块化细节

### 前言

- 时长：33min

```shell
# 老规矩，先初始化一个简单的环境。
npm init
# ...
npm i -D @types/node # 智能提示
```

### 模块的查找

#### 绝对路径

```js
// 1.js
console.log("1.js");
```

```js
// index.js
require("C:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\1.js");
```

在 index.js 中使用 1.js 的绝对路径导入 1.js。

导入模块时，我们可以使用绝对路径来导入。并且其它形式的写法，最终都会转为绝对路径。导入模块的本质，其实就是读取文件，在读文件的时候，我们得使用绝对路径来读取。

#### 相对路径

##### 以 ./ 或 ../ 开头

```js
// 2.js
console.log("2.js");
```

```js
require("./2.js");
```

在 index.js 中使用 2.js 的相对路径导入 2.js。

使用相对路径 `./` 或 `../` 来导入模块。路径是相对于当前模块的路径，最终会转换为绝对路径。

##### 不以 ./ 或 ../ 开头

同样是表示相对路径，但是，可以不再以 `./` 或 `../` 开头。

```js
// node_modules 目录下的 abc 目录下的 index.js 文件（手动创建）
console.log("./node_modules/abc/index.js");
```

```js
// 根目录下的 index.js 文件
require("abc"); // => ./node_modules/abc/index.js
```

此时，`require("abc")` 这种导入模块的写法，可以定位到 `./node_modules/abc/index.js`。

**查找逻辑**

1. 首先，判断 abc 是否是一个 node 的内置模块。
2. 若不是，则 abc 会被识别为一个**目录**，按照**目录的查找逻辑**进行查找。
3. 若没找到，再将其视作一个**文件**，然后按照**文件的查找逻辑**进行查找。
4. 找到后，转换为绝对路径，并加载模块；找不到，则报错。

**require("./abc")**

若导入语句是这么写的话，那么查找逻辑 2 和 3 先后顺序互换。

1. 首先，判断 abc 是否是一个 node 的内置模块。
2. 若不是，则 abc 会被识别为一个**文件**，按照**文件的查找逻辑**进行查找。
3. 若没找到，再将其视作一个**目录**，然后按照**目录的查找逻辑**进行查找。
4. 找到后，转换为绝对路径，并加载模块；找不到，则报错。

##### 文件的查找逻辑

下面这 3 种写法，xxx 都将被识别为文件，先按照文件的查找逻辑进行查找。若找不到指定文件，在识别为目录。

- require(./xxx)
- require(../xxx)
- require(???/xxx)

下面这种写法，只会将 xxx 识别为文件，并按照文件的查找逻辑查找。

- require(xxx.后缀)

**./xxx 或 ../xxx 或 ???/xxx**

若我们在导入模块的时候，没有提供后缀名，那么，后缀名将自动补全。js、json、node、mjs，从左到右依次试，一旦匹配上，就导入对应的模块。

```json
// abc.json
{
  "filename": "abc.json"
}
```

```js
// index.js
const result = require("./abc");
console.log(result); // => { filename: 'abc.json' }
```

若根目录下没有找到 abc.js，找到了 abc.json，则会导入 abc.json 文件中的内容。后缀名为 node、mjs 的文件以此类推。

**xxx.后缀**

```js
// ./abc.js
console.log("abc.js");
```

```js
// 在根目录下找 abc.js、abc.json、abc.node、abc.mjs
require("./abc"); // => abc.js
```

##### 目录的查找逻辑

下面这种写法，xxx 会被识别为目录，按照目录的查找逻辑查找。

- require(xxx)

若我们在导入模块的时候，仅提供了文件名（目录），则默认查找该文件名（目录）下的 index.js 文件（仅提供文件名，表示从 package.json 中读取包默认入口）。因为 package.json 中的 main 字段，默认值就是 index.js，在导入指定文件名下的模块时，会读取 package.json 中的 main 字段，将其作为包的默认入口。

查找都是从当前文件所在的目录开始的，若当前文件所在的目录下不存在 node_modules 目录，或者，在当前文件所在的目录下的 node_modules 目录下找不到指定文件时，才会到当前目录的上层目录下，继续找 node_modules 目录。不断重复，直到找到根。

```js
// ./node_modules/abc/index.js
console.log("./node_modules/abc/index.js");
```

```js
// ./node_modules/abc/a.js
console.log("./node_modules/abc/a.js");
```

```json
// ./node_modules/abc/package.json
{
  "main": "a.js"
}
```

```js
// ./index.js
require("abc"); // => ./node_modules/abc/a.js
```

如果我们设置了 main 字段，那么，导入的将会是 main 字段指定的文件。

```js
// ./node_modules/abc/index/index.js
console.log("./node_modules/abc/index/index.js");
```

```js
// ./index.js
require("abc/index"); // => ./node_modules/abc/index.js
```

如果按照这种写法来写，那么，会在对应的 node_modules 目录下查找 abc 目录，然后再去查找 index **文件**（注意，会先将 index 视作文件，而非目录），然后在 abc 目录下按照**文件的查找逻辑**进行查找。若都未查找到，则将 index 视作一个**目录**，在该目录下读取 package.json 中设置的 main 字段，再导入指定文件。所以，若我们将 abc 目录下的 index.js 文件给删了，同时在 abc 目录下新增一个名为 index 的目录，该目录下有一个名为 index.js 的文件，那么我们再去导入 `"abc/index"` 时，将会导入 `abc/index/index.js`。

```js
// 删除 ./node_modules/abc/index.js 文件
console.log("./node_modules/abc/index.js");
```

```js
// ./index.js
require("abc/index"); // => ./node_modules/abc/index/index.js
```


**小结**

模块的查找，比较复杂。但是，如果是绝对路径，或者是带有指定文件后缀名的相对路径，理解起来就很简单。

**难点**

比较下面这几种写法的区别。

```js
require("fs");
require("abc");
require("abc/a");
require("abc/a.js");
```

- `require("fs");` 由于 fs 是内置模块，这么写相当于直接导入内置模块 fs；
- `require("abc");` 到对应的 node_modules 目录下的 abc 目录下的 package.json 的 main 字段中查找入口模块；
- `require("abc/a");` 到对应的 node_modules 目录下的 abc 目录下，先将 a 视作一个没有写后缀名的文件，尝试给它补全后缀名，然后看是否可以查找到指定文件，若没有查找到，则将 a 视作一个目录，在 a 目录下的 package.json 的 main 字段中查找入口模块；
- `require("abc/a.js");` 到对应的 node_modules 目录下的 abc 目录下，查找 a.js 文件。

> 细节比较多，根据自己的理解，各种情况都试试。
> 上面记录的内容，是目前能想到的所有情况。
> 如何查看具体加载的是哪一个模块，我们可以使用 `require.resolve(模块路径);` 来查看，该函数会将我们传入的模块路径解析为最终需要导入的模块所在的绝对路径。它并不会执行被导入模块中的代码。

### module 对象

- [ ] index.js

```js
console.log(module);

/*
Module {
  id: '.',
  // => 如果该模块是一个入口模块，那么 id 是一个 . 否则，id 为该模块的绝对路径
  path: 'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\module 对象',
  // => 表示的是该模块所在的目录
  exports: {},
  // => 表示该模块的导出内容
  parent: null,
  // => 表示哪个模块正在使用该模块，它也是一个 Module 对象（或 null 入口模块没有父模块）
  filename: 'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\module 对象\\index.js',
  // => 表示该模块的绝对路径
  loaded: false,
  // => 表示当前模块是否加载完了
  children: [],
  // => 当前模块依赖（导入）的子模块
  paths: [
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\module 对象\\node_modules',
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\node_modules',
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\node_modules',
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\node_modules',
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\node_modules',
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\node_modules',
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\node_modules',
    'c:\\Users\\dahuyou\\Desktop\\node_modules',
    'c:\\Users\\dahuyou\\node_modules',
    'c:\\Users\\node_modules',
    'c:\\node_modules'
  ]
  // => paths 表示的模块的查找顺序（使用 require("abc") 这种模式加载模块时，会依据这个 paths 数组来查找我们想要导入的指定模块。）
}
*/
```

module 对象，是 node 内部使用 Module 构造函数，帮我们创建的一个对象，记录了当前模块的相关信息。

### require 函数

- [ ] index.js

```js
console.log(require);
/*
[Function: require] {
  resolve: [Function: resolve] { paths: [Function: paths] },
  // => resolve 是一个函数，作用是将我们传入的模块的路径转换为一个绝对路径。
  main: Module {
    id: '.',
    path: 'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\require 函数',
    exports: {},
    parent: null,
    filename: 'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\require 函数\\index.js',
    loaded: false,
    children: [],
    paths: [
      'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\require 函数\\node_modules',
      'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\node_modules',
      'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\node_modules',
      'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\node_modules',
      'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\node_modules',
      'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\node_modules',
      'c:\\Users\\dahuyou\\Desktop\\fenotes\\node_modules',
      'c:\\Users\\dahuyou\\Desktop\\node_modules',
      'c:\\Users\\dahuyou\\node_modules',
      'c:\\Users\\node_modules',
      'c:\\node_modules'
    ]
  },
  // => main 指的是 node 命令运行的主模块
  extensions: [Object: null prototype] {
    '.js': [Function (anonymous)],
    '.json': [Function (anonymous)],
    '.node': [Function (anonymous)]
  },
  // => 映射表 => 被导入的模块的拓展名: 处理函数 => 拓展名不同，对应的处理函数也不同
  cache: [Object: null prototype] {
    'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\require 函数\\index.js': Module {
      id: '.',
      path: 'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\require 函数',
      exports: {},
      parent: null,
      filename: 'c:\\Users\\dahuyou\\Desktop\\fenotes\\nodejs\\袁进\\1. Node核心\\1-3. Node的模块化细节\\codes\\require 函数\\index.js',
      loaded: false,
      children: [],
      paths: [Array]
    }
  }
  // => 表示目前已经缓存的模块，任何的模块化规范其实都是有缓存的，不仅仅是 commonJS 规范。每个缓存，都是一个 Module 对象，属性名为模块 id，属性值为 模块对象，若导入的模块在 cache 中，那么直接从 cache 中查找即可。
}
*/
```

### 模块化实现原理

如何实现的模块化，如何让导入的模块中的变量成为局部变量，不污染全局？

- [ ] 面试题，请问：该模块导出的结果是？

```js
// myModule1.js
this.m = 5;
exports.c = 3;
module.exports = {
  a: 1,
  b: 2
};
```

```js
// myModule2.js
exports.c = 3;
module.exports = {
  a: 1,
  b: 2
};
this.m = 5;
```

```js
// myModule3.js
exports.c = 3;
module.exports.a = 1;
module.exports.b = 2;
this.m = 5;
```

```js
// index.js
console.log(require("./myModule1.js")); // => { a: 1, b: 2 }
console.log(require("./myModule2.js")); // => { a: 1, b: 2 }
console.log(require("./myModule3.js")); // => { c: 3, a: 1, b: 2, m: 5 }
```

当执行一个模块或使用 require 函数时，会将模块放置到一个函数环境中，函数被调用时，实参中带有 module、exports、require、__dirname、__filename。这就是为什么我们可以直接使用 __dirname、__filename（它们都不是 global 对象身上的属性）。

```js
function require(modulePath) {
  // 1. 将 modulePath 转换为绝对路径，若没有找到对应的模块，则报错，否则继续后续操作。
  // 2. 判断 cache 中，是否已经缓存了该模块，若有缓存，则直接从 cache 中拿该模块。
  // 3. 若 cache 中没有缓存该模块，则读取文件内容，导入该模块，并在 cache 中添加该模块的缓存。
  // 4. 将读取到的内容包裹到一个函数中，函数的参数中带有 module、exports、require、__dirname、__filename。
  // 5. 创建 module 对象，并使用 call 调用第 4 步的函数，将 this 指向绑定为 module.exports。
  // 6. 最终返回 module.exports
}
```

下面是仿照 require 函数的原理，仿写的一个 myRequire，简单看看大致的逻辑即可。

```js
// require 原理（伪代码）
function myRequire(modulePath) {
  // 1
  modulePath = require.resolve("./myModule1.js");
  // 2
  if (require.cache[modulePath]) {
    // 有缓存，直接导出缓存。
    return require.cache[modulePath];
  }
  // 3 + 4 没缓存，读取文件内容，并将文件内容封装到一个函数中。
  function __temp(module, exports, require, __dirname, __filename) {
    // 文件内容
    console.log("当前模块路径：", __dirname);
    console.log("当前模块文件：", __filename);
    this.m = 5;
    exports.c = 3;
    module.exports = {
      a: 1,
      b: 2
    };
  }
  // 5
  module.exports = {};
  const exports = module.exports;
  __temp.call(module.exports, module, exports, require, module.path, module.filename);
  // 6
  return module.exports;
}
```

看到这里，能够了解到以下几个点：
- node 中 this 的指向
- 为什么 __dirname、__filename 这些不是全局对象 global 身上的属性，我们可以直接用
- exports、module.exports、this 之间的区别

---

- [ ] 练习.js

```js
console.log(this === exports); // => true
console.log(this === module.exports); // => true
module.exports = {}; // 重新改变 module.exports 的指向
console.log(this === exports); // => true
console.log(this === module.exports); // => false
// 最终返回的是 module.exports
```

```js
// index.js
require("./练习.js");
```

