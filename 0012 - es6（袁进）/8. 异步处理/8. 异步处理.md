# 8. 异步处理 {ignore}

[toc]

## 前言

参考文章: [async 函数的含义和用法 (阮一峰的网络日志)](http://www.ruanyifeng.com/blog/2015/05/async.html)

`8. 异步处理 [课程规划与指导]`

| 知识点 | 难度 | 重要性 | 学习视频                           | 视频时长(min) | 学习次数 |
| ------ | ---- | ------ | ---------------------------------- | ------------- | -------- |
| es6    | 3.5  | 5      | 8-0. [回顾]事件循环.mp4            | 71            | 3/2      |
| es6    | 3.5  | 4      | 1. 事件和回调函数的缺陷            | 39            | 3/2      |
| es6    | 3    | 5      | 2. 异步处理的通用模型              | 23            | 3/2      |
| es6    | 3    | 5      | 3. Promise的基本使用               | 38            | 3/2      |
| es6    | 4    | 4      | 4. Promise的串联                   | 57            | 3/2      |
| es6    | 4    | 4      | 5. Promise的其他api                | 31            | 3/2      |
| es6    | 5    | 2.5    | 6. [扩展]手写Promise - 状态控制    | 18            | 3/1      |
| es6    | 5    | 2.5    | 6. [扩展]手写Promise - 后续处理    | 17            | 3/1      |
| es6    | 5    | 2.5    | 6. [扩展]手写Promise - 串联Promise | 15            | 3/1      |
| es6    | 5    | 2.5    | 6. [扩展]手写Promise - 其他API     | 12            | 3/1      |
| es6    | 4    | 5      | 7. async和await                    | 42            | 3/2      |

| 学习时间 | 达成效果                                        | 老师建议                                                                                                                                                          |
| -------- | ----------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| 2天      | 学会在异步场景中使用Promise学会使用async和await | 这一章的知识难度比较高，同时又非常的重要，很多课都需要重复的观看并练习，千万不要急于求成如果普通课程看起来都比较吃力，不建议看本章的扩展，先理解它的API是最重要的 |

**思考以下几个问题**

- [x] `const pro2 = pro1.then()` pro1.then() 返回的 pro2 一开始一定是 pending 状态吗? `答: √, 因为 pro1.then() 的then方法中的代码是异步执行的, 所以 给 pro2 赋值的操作 一定会先于 then方法中的异步代码执行(即: 在pro1.then()有处理结果之前, 就得 pro2 进行了赋值), 而 pro2 被推向 settled 阶段必须要等到前一个 promise 即: pro1, 有了处理结果之后`

**注意**

```
ES 的 Promise 规范好像更新了 这就导致了一个问题 ==> 有一些输出结果和老师的会对不上
尤其是 resolved 和 fulfilled 这两个状态值的问题

Promise A+ 规范中 resolved 被改为 fulfilled ==> 在学习过程中 暂且先将它们看作是同一个东西即可
```

**字节面试题**

```js{cmd='node'}
console.log(1);

setTimeout(() => {
    console.log(2);
}, 0);

new Promise(resolve => {
    console.log(3);
    resolve();
}).then(() => {
    console.log(4);
});

console.log(5);

/*
1
3
5
4
2
*/
```

## 8.0 [回顾]事件循环

**回答以下几个问题**

- [x] 什么是 EventLoop?
- [x] 什么是 call stack?
- [x] 什么是 event queue?
- [x] 什么是 宿主环境?
- [x] 什么是 异步函数?
- [x] 浏览器宿主环境共有几个线程?
- [ ] 浏览器的各个线程分别负责什么工作?

**理解异步程序**

- [x] demo

```js
console.log('a'); // 同步

const timer = setInterval(() => {
    console.log('b'); // 异步
    clearInterval(timer); // 异步
}, 0);

console.log('c'); // 同步
```

![20210417153421](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417153421.png)

- [x] demo

```js
console.log('a'); // 同步

const timer = setInterval(() => {
    console.log('b'); // 异步
    clearInterval(timer); // 异步
}, 0);

for (let i = 0; i < 1000; i++) {
    console.log('c'); // 同步
}
```

![20210417153603](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417153603.png)

```
同步程序 VS 异步程序
    JS程序由上至下依次执行
    若执行到同步程序 那么会将它直接丢到 call stack(执行栈) 中等待 JS 引擎执行
    若执行到异步程序 那么该异步程序会先被丢到 event queue(事件队列) 排队, 等待被 call stack(执行栈) 调用, 只有当 call stack(执行栈) 中的内容为空时, call stack 才会去 event queue(事件队列) 中取东西来等待 JS引擎 执行
小结:
    1. 同步程序 一定比 异步程序 先执行
    2. 异步程序若要执行 必定会经过 event queue (事件队列) 并且 事件队列中的程序 必定要等到 call stack 为空时 才会被取出执行

PS: 这些关键性的名词 有很多叫法 理解概念更重要
    比如: 事件队列 也叫 任务队列
```

**宿主环境**

JS (ES) 运行的环境称之为宿主环境。

```
更合理的说法应该是 ES 可以运行在很多宿主环境中
当 ES 运行在 浏览器这一宿主环境中时 就是 JavaScript
当 ES 运行在 服务器端这一宿主环境中时 就是 NodeJS
ES 还有其他很多的宿主环境 其中也包括客户端 比如 vscode 这款编辑器就是使用 JavaScript 来写的
    让 ES 在不同的宿主环境中运行 只要提供好对应的 引擎 就OK
这门课更多学习的是 ES6 学习的是 ES 是语言本身 而仅不限于某个宿主环境
```

![20210510082417](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510082417.png)

**执行栈 call stack**

执行栈：call stack，它是一个数据结构，用于存放各种函数的执行环境，每一个函数执行之前，它的相关信息会加入到执行栈。函数调用之前，创建执行环境，然后加入到执行栈；函数调用之后，销毁执行环境。

JS引擎永远执行的是执行栈的最顶部。

```
1. JS程序的执行 只会创建一个执行栈
2. JS程序的执行 首先会创建一个 全局上下文 (也叫全局的执行环境) 这个全局上下文会被 push 到 call stack 中 它位于 call stack 的栈底 最先如栈 最后出栈
3. 函数在执行之前 会创建一个与之对应的上下文 然后 push 到 call stack 中 执行完后 该上下文被销毁 pop
4. JS引擎 执行的始终都是栈顶的那个上下文
5. 程序执行完后 全局的执行上下文 pop

全局上下文: global context
函数的局部上下文: execution context
```

- [x] demo

```js{cmd='node'}
function a() {
    console.log('a');
    b();
}

function b() {
    console.log('b');
    c();
}

function c() {
    console.log('c');
}

console.log('global');
a();
```

```
简单分析 call stack 的变化
1. push global context ==> 全局上下文入栈
   push log 的 execution context ==> log的上下文入栈
   pop log 的 execution context ==> log的上下文出栈
2. push a 的 execution context ==> a的上下文入栈
3. push log 的 execution context ==> log的上下文入栈
4. pop log 的 execution context ==> log的上下文出栈
5. push b 的 execution context ==> b的上下文入栈
6. push log 的 execution context ==> log的上下文入栈
7. pop log 的 execution context ==> log的上下文出栈
8. push c 的 execution context ==> c的上下文入栈
9. push log 的 execution context ==> log的上下文入栈
10. pop log 的 execution context ==> log的上下文出栈
11. pop c 的 execution context ==> c的上下文出栈
12. pop b 的 execution context ==> b的上下文出栈
13. pop a 的 execution context ==> a的上下文出栈
14. pop global context ==> 全局的上下文出栈

小结: 3个函数的入栈和出栈的先后顺序
    函数a先执行 a还没执行完 函数b入栈 b还没执行完 函数c入栈
    函数c最先执行完 函数c出栈 ==> 函数b执行完 函数b出栈 ==> 函数a执行完 函数a出栈
    入栈顺序: 函数a -> 函数b -> 函数c
    出栈顺序: 函数c -> 函数b -> 函数a

视频: 13min -> 20min
```

- [x] demo

```js
function a() {
    b();
    console.log('a');
}

function b() {
    c();
    console.log('b');
}

function c() {
    console.log('c');
}

console.log('global');
a();
```

![20210417154833](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417154833.png)

- [x] demo

`递归 - 斐波拉切数列`

```js
/**
 * 获取斐波拉切数列的第n位
 * @param {Number} n
 */
function getFeibo(n) {
    if (n === 1 || n === 2) {
        return 1;
    }
    return getFeibo(n - 1) + getFeibo(n - 2);
}

console.log(getFeibo(4)); // 3
```

![20210417161507](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417161507.png)

```
这个案例用来理解递归 特别合适 该程序的执行流程 必须得明明白白
可以先自己在纸上画一个执行栈 然后一步一步的执行 一步一步的分析
也可以结合控制台来看看自己的分析是否正确 或者 回看视频 19min -> 30min

简单分析 call stack 的变化
1. push global context ==> 全局上下文入栈
2. push getFeibo 的 execution context (n === 4) ==> getFeibo 的上下文入栈 此时 n 等于 4
接下来计算 geiFeibo(4)
    3. push getFeibo 的 execution context (n === 3) ==> getFeibo 的上下文入栈 此时 n 等于 3
    接下来计算 getFeibo(3)
        4. push getFeibo 的 execution context (n === 2) ==> getFeibo 的上下文入栈 此时 n 等于 2
        接下来计算 getFeibo(2)
            5. pop getFeibo 的 execution context (n === 2) ==> getFeibo 的上下文出栈 此时 n 等于 2 ==> 返回 1
            得到 getFeibo(2) 的结果 ==> 1
        6. push getFeibo 的 execution context (n === 1) ==> getFeibo 的上下文入栈 此时 n 等于 1
        接下来计算 getFeibo(1)
            7. pop getFeibo 的 execution context (n === 1) ==> getFeibo 的上下文出栈 此时 n 等于 1 ==> 返回 1
            得到 getFeibo(1) 的结果 ==> 1
    得到 getFeibo(3) 的结果 2
    8. push getFeibo 的 execution context (n === 2) ==> getFeibo 的上下文入栈 此时 n 等于 2
    接下来计算 getFeibo(2)
        9. pop getFeibo 的 execution context (n === 2) ==> getFeibo 的上下文出栈 此时 n 等于 2 ==> 返回 1
        得到 getFeibo(2) 的结果 ==> 1

... 这个动态过程实在不好描述 还是动手画一画吧 结合视频进行验证 自己的分析过程是否正确 理解了即可

这个分析过程 和 二叉树的遍历很相似
```

`入栈顺序`

![20210425182426](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210425182426.png)

`出栈顺序`

![20210425182520](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210425182520.png)

**异步函数**

异步函数：某些函数不会立即执行，需要等到某个时机到达后才会执行，这样的函数称之为异步函数。比如事件处理函数`再比如 ajax 的成功回调函数; setinterval 的第一个参数也是一个异步函数`。异步函数的执行时机，会被宿主环境控制。

```
JS的主线程是单线程的 即: JS代码的执行线程 只有一个
小结:
    异步函数的执行 需要等待时机, 由宿主环境来监听
```

**浏览器宿主环境中包含5个线程：**

1. JS引擎：负责执行执行栈的最顶部代码
2. GUI线程：负责渲染页面
3. 事件监听线程：负责监听各种事件
4. 计时线程：负责计时
5. 网络线程：负责网络通信

```
PS: JS引擎 和 GUI线程 两者不会同时工作 一个在工作时 另一个就在等待
```

**事件循环**

当上面的线程发生了某些事请，如果该线程发现，这件事情有处理程序，它会将该处理程序加入一个叫做事件队列的内存。当JS引擎发现，执行栈中已经没有了任何内容后，会将事件队列中的第一个函数加入到执行栈中执行。

JS引擎对事件队列的取出执行方式，以及与宿主环境的配合，称之为事件循环。

```
PS: 异步函数若被执行 必定经过事件队列 才会到被 JS引擎执行
```

**事件队列**

事件队列在不同的宿主环境中有所差异，大部分宿主环境会将事件队列进行细分。在浏览器中，事件队列分为两种：

- 宏任务（队列）`macro`：macroTask，计时器结束的回调、事件回调、http回调等等绝大部分异步函数进入宏队列
- 微任务（队列）`micro`：MutationObserver，Promise产生的回调进入微队列

> MutationObserver用于监听某个DOM对象的变化

当执行栈清空时，JS引擎首先会将微任务中的所有任务依次执行结束，如果没有微任务，则执行宏任务。

| 宏任务（Macrotask）      | 微任务（Microtask）             |
| ------------------------ | ------------------------------- |
| setTimeout               | requestAnimationFrame（有争议） |
| setInterval              | MutationObserver（浏览器环境）  |
| MessageChannel           | Promise.[ then/catch/finally ]  |
| I/O，事件队列            | process.nextTick（Node环境）    |
| setImmediate（Node环境） | queueMicrotask                  |
| script（整体代码块）     |                                 |

- [x] demo

```html
<ul id="container"></ul>
<button id="btn">点击</button>
```

```js
let count = 1;
const ul = document.getElementById("container");
document.getElementById("btn").onclick = function A() {
    setTimeout(function C() {
        console.log("执行了函数 C")
    }, 0);
    var li = document.createElement("li");
    li.innerText = count++;
    ul.appendChild(li);
    console.log('执行了函数 A ==> 添加了一个li');
}

// 监听ul
const observer = new MutationObserver(function B() {
    // 当监听的dom元素发生变化时运行的回调函数
    console.log("执行了函数 B ==> ul元素发生了变化")
})
// 监听ul
observer.observe(ul, {
    attributes: true, //监听属性的变化
    childList: true, //监听子元素的变化
    subtree: true //监听子树的变化
})
// 取消监听
// observer.disconnect();
```

```
当按钮被点击之后 控制台依次输出的内容如下图所示
```

![20210417165043](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417165043.png)

**小结**

```
1. 同步函数 会直接丢到 call stack 中执行
2. 异步函数 先丢到浏览器的线程中 监听 一旦发生了某些事(触发了异步函数执行) 那么该异步函数就会被丢到 事件队列 event queue 中
   等到 call stack 中的事情处理完了之后 call stack 才会去调用 事件队列 event queue 中的东西来执行
3. 若 微队列 和 宏队列 中都有东西等待被调用
   那么 处于 微队列 micro 中的内容优先被调用 宏队列 macro 中的内容后调用
```

## 8.1 事件和回调函数的缺陷

我们习惯于使用传统的回调或事件处理来解决异步问题

**事件处理函数 和 回调函数**

事件：某个对象的属性是一个函数，当发生某一件事时，运行该函数

```js
dom.onclick = function(){

}
```

回调：运行某个函数以实现某个功能的时候，传入一个函数作为参数，当发生某件事的时候，会运行该函数。

```js
dom.addEventListener("click", function(){

})
```

**它们的本质**

事件和回调并没有本质的区别，只是把函数放置的位置不同而已。

**它们所带来的一些问题**

一直以来，该模式都运作良好。

直到前端工程越来越复杂...

目前，该模式主要面临以下两个问题：

1. 回调地狱：某个异步操作需要等待之前的异步操作完成，无论用回调还是事件，都会陷入不断地嵌套
2. 异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增

```
这两个问题 描述起来非常抽象 可以多写几遍下面的 4 个demo
并且在学完 8. 异步处理 这一部分的全部内容后 再利用所学的知识点来写一遍下面的 4 个demo
体会体会区别 这样效果应该会更好
```

> 下面这 4 个 demo 看懂即可 别再写了 之后有更好的写法

- [x] demo1 - 回调地狱1

```
需求描述:
    页面中有3个btn 当依次点击 btn1 btn2 btn3 时 才会弹出 hello world!!!
```

```html
<!DOCTYPE html>
<html lang="en">

<head>
    <title>回调地狱 - 1</title>
</head>

<body>
    <button id="btn1">按钮1: 给按钮2注册点击事件</button>
    <button id="btn2">按钮2: 给按钮3注册点击事件</button>
    <button id="btn3">按钮3: 弹出 hello world</button>
    <script>
        const btn1 = document.getElementById('btn1'),
            btn2 = document.getElementById('btn2'),
            btn3 = document.getElementById('btn3');
        btn1.addEventListener('click', function() {
            btn2.addEventListener('click', function () {
                btn3.addEventListener('click', function () {
                    alert('hello world');
                });
            });
        });
    </script>
</body>

</html>
```

- [x] demo2 - 回调地狱2

```
需求描述:
    场景:
      邓哥心中有三个女神
      有一天，邓哥决定向第一个女神表白
      如果女神拒绝，则向第二个女神表白
      直到所有的女神都拒绝 或 有一个女神同意为止
      表白的时间间隔为 1s
    用代码模拟上面的场景
```

```js
function biaobai(god, callback) {
    console.log(`邓哥向女神【${god}】发出了表白短信`);
    setTimeout(() => {
        if (Math.random() < 0.1) { // 同意了
            callback(true);
        } else { // 拒绝了
            callback(false);
        }
    }, 1000);
}

biaobai('女神1', function (result) {
    if (result) {
        console.log('女神1 ==> 同意');
    } else {
        console.log('女神1 ==> 拒绝');
        biaobai('女神2', function (result) {
            if (result) {
                console.log('女神2 ==> 同意');
            } else {
                console.log('女神2 ==> 拒绝');
                biaobai('女神3', function (result) {
                    if (result) {
                        console.log('女神3 ==> 同意');
                    } else {
                        console.log('女神3 ==> 拒绝');
                        console.log('所有女神都拒绝了');
                    }
                });
            }
        });
    }
});
```

`使用串联的 promise 来实现 (属于 第4节 promise的串联 的知识点)`

```js
function biaobai(god) {
    return new Promise((resolve, reject) => {
        console.log(`邓哥向女神【${god}】发出了表白短信`);
        setTimeout(() => {
            if (Math.random() < 0.1) { // 同意了
                resolve(true);
            } else { // 拒绝了
                resolve(false);
            }
        }, 1000);
    });
}

biaobai('女神1').then(result => {
    if (result) {
        console.log('女神1 ==> 同意');
        return;
    } else {
        console.log('女神1 ==> 拒绝');
        return biaobai('女神2');
    }
}).then(result => {
    if (result === undefined) {
        return;
    } else if (result === true) {
        console.log('女神2 ==> 同意');
        return;
    } else {
        console.log('女神2 ==> 拒绝');
        return biaobai('女神3');
    }
}).then(result => {
    if (result === undefined) {
        return;
    } else if (result === true) {
        console.log('女神3 ==> 同意');
        return;
    } else {
        console.log('女神3 ==> 拒绝');
        console.log('所有女神都拒绝了');
    }
});
```

`使用 async 和 await 关键字来实现 (最后一节课的知识点)`

```js
function biaobai(god) {
    console.log(`邓哥向女神【${god}】发出了表白短信`);
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (Math.random() < 0.1) { // 同意了
                resolve(true);
            } else { // 拒绝了
                resolve(false);
            }
        }, 1000);
    });
}

async function handler() {
    let result = await biaobai('女神1');
    if (result) {
        console.log('女神1 ==> 同意');
        return;
    } else {
        console.log('女神1 ==> 拒绝');
        result = await biaobai('女神2');
    }
    if (result) {
        console.log('女神2 ==> 同意');
        return;
    } else {
        console.log('女神2 ==> 拒绝');
        result = await biaobai('女神3');
    }
    if (result) {
        console.log('女神3 ==> 同意');
        return;
    } else {
        console.log('女神3 ==> 拒绝');
        console.log('所有女神都拒绝了');
    }
}

handler();
```

- [x] demo3 - 回调地狱3

```
需求描述:
    获取李华所在班级的老师信息
    PS: 相关数据到 assets 中查看
```

```js
ajax({
    url: './data/students.json?name=李华',
    success(data) {
        for (let i = 0; i < data.length; i++) {
            const stu = data[i];
            if (stu.name === '李华') {
                const cid = stu.classId; // 获取到班级id
                console.log(`获取到李华所在的班级id: ${cid}`);
                ajax({
                    url: './data/classes.json?classId=' + cid,
                    success(data) {
                        for (let i = 0; i < data.length; i++) {
                            const cl = data[i];
                            if (cl.id === cid) {
                                const tid = cl.teacherId;
                                console.log(`获取到班级id为: ${cid} 的老师id: ${tid}`);
                                ajax({
                                    url: './data/teachers.json?teacherId=' + tid,
                                    success(data) {
                                        for (let i = 0; i < data.length; i++) {
                                            const t = data[i];
                                            if (t.id === tid) {
                                                console.log(`获取到id为: ${tid} 的老师信息`, t);
                                            }
                                        }
                                    }
                                });
                            }
                        }
                    }
                });
            }
        }
    }
});
```

![20210510183008](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510183008.png)

```
1. 通过学生姓名 李华 在 students.json 中找到指定学生信息
2. 通过学生信息 获取学生所在的班级id classId
3. 在 classes.json 通过班级id 获取到老师的id teacherId
4. 最后通过 teacherId 在 teachers.json 中获取指定的老师信息
实现思路其实很简单 但是代码看起来... 很乱
```

`使用串联的promise来实现`

> 需要修改一下 ajax 函数, 让它返回一个 promise 对象

`这是原来封装的一个 ajax 函数`

```js
function toData(data) {
    if (data === null || typeof data !== 'object') {
        return data;
    } else {
        let arr = [];
        for (const prop in data) {
            arr.push(`${prop}=${data[prop]}`);
        }
        return arr.join('&');
    }
}

function createXMLHttpRequest() {
    let xhr = null;
    if (window.XMLHttpRequest) {
        xhr = new XMLHttpRequest();
    } else {
        xhr = new ActiveXObject('Microsoft.XMLHTTP');
    }
    return xhr;
}

function ajax({
    method = 'GET',
    url = '',
    async = true,
    data = null,
    dataType = 'json',
    beforeSend = function () {},
    success = function () {},
    error = function () {}
}) {
    let xhr = createXMLHttpRequest();

    beforeSend();

    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                success(JSON.parse(xhr.responseText));
            } else {
                error(xhr.status);
            }
        }
    }

    method = method.toUpperCase();
    data = toData(data);

    if(method === 'GET') {
        xhr.open(method, `${url}?${data}`, async);
        xhr.send();
    }else if (method === 'POST') {
        xhr.open(method, url, async);
        xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencode');
        xhr.send(data);
    }
}
```

`修改后`

```js
// toData 和 createXMLHttpRequest 这两个函数保持不变 只要修改一下 ajax 即可
function ajax({
    method = 'GET',
    url = '',
    async = true,
    data = null,
    dataType = 'json',
    beforeSend = function () {},
    success = function () {},
    error = function () {}
}) {
    return new Promise((resolve, reject) => {
        let xhr = createXMLHttpRequest();

        beforeSend();

        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300 || xhr.status === 304) {
                    resolve(JSON.parse(xhr.responseText));
                } else {
                    reject(xhr.status);
                }
            }
        }

        method = method.toUpperCase();
        data = toData(data);

        if(method === 'GET') {
            xhr.open(method, `${url}?${data}`, async);
            xhr.send();
        }else if (method === 'POST') {
            xhr.open(method, url, async);
            xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencode');
            xhr.send(data);
        }
    });
}
```

`[补充] 也可以不直接修改 ajax 函数内部的内容 而是在外面重新给 ajax 包裹上一层 promise`

```js
const pro = new Promise((resolve, reject) => {
    ajax({
        url: '',
        success(data) {
            resolve(data);
        },
        error(err) {
            reject(err);
        }
    })
});
```

```js
ajax({
    url: './data/students.json?name=李华',
}).then(stus => {
    for (let i = 0; i < stus.length; i++) {
        const stu = stus[i];
        if (stu.name === '李华') {
            const cid = stu.classId; // 获取到班级id
            console.log(`获取到李华所在的班级id: ${cid}`);
            return cid;
        }
    }
}).then(cid => {
    return ajax({
        url: './data/classes.json?classId=' + cid,
    }).then(cls => {
        for (let i = 0; i < cls.length; i++) {
            const cl = cls[i];
            if (cl.id === cid) {
                const tid = cl.teacherId;
                console.log(`获取到班级id为: ${cid} 的老师id: ${tid}`);
                return tid;
            }
        }
    });
}).then(tid => {
    return ajax({
        url: './data/teachers.json?teacherId=' + tid,
    }).then(ts => {
        for (let i = 0; i < ts.length; i++) {
            const t = ts[i];
            if (t.id === tid) {
                console.log(`获取到id为: ${tid} 的老师信息`, t);
                return t;
            }
        }
    });
}).then(t => {
    console.log('此时已经获取到了李华的老师信息, 下面可以对其进行相关操作');
    console.log(t);
});
```

![20210510184718](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510184718.png)

`使用 async 和 await 来实现`

```js
async function handler() {
    const cid = await ajax({ // 获取所有的学生信息
        url: './data/students.json'
    }).then(stus => {
        for (let i = 0; i < stus.length; i++) {
            const stu = stus[i];
            if (stu.name === '李华') {
                const cid = stu.classId; // 获取到班级id
                console.log(`获取到李华所在的班级id: ${cid}`);
                return cid;
            }
        }
    });
    const tid = await ajax({
        url: './data/classes.json'
    }).then(cls => {
        for (let i = 0; i < cls.length; i++) {
            const cl = cls[i];
            if (cl.id === cid) {
                const tid = cl.teacherId;
                console.log(`获取到班级id为: ${cid} 的老师id: ${tid}`);
                return tid;
            }
        }
    });
    const t = await ajax({
        url: './data/teachers.json'
    }).then(ts => {
        for (let i = 0; i < ts.length; i++) {
            const t = ts[i];
            if (t.id === tid) {
                console.log(`获取到id为: ${tid} 的老师信息`, t);
                return t;
            }
        }
    });
    console.log('此时已经获取到了李华的老师信息, 下面可以对其进行相关操作');
    console.log(t);
}

handler();
```

![20210510185344](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510185344.png)

```
[分析] 对比三种实现方式, 最终版本 async 和 await 结合来实现的方式最好, 因为它让我们在编写异步代码的时候, 感觉像是在编写同步代码一样;
[注] 不能用 async 来修饰被调用的函数 也就是不能在 调用 ajax 的前面写 async, 这么做是无效的
```

- [x] demo4 - 回调地狱4

```
需求描述:
    邓哥心中有二十个女神，他决定用更加高效的办法
    他同时给二十个女神表白，如果有女神同意，就拒绝其他的女神
    并且，当所有的女神回复完成后，他要把所有的回复都记录到日志进行分析
    用代码模拟上面的场景
```

```js
function biaobai(god, callback) {
    console.log(`邓哥向女神【${god}】发出了表白短信`);
    setTimeout(() => {
        if (Math.random() < 0.1) { // 同意了
            callback(true);
        } else { // 拒绝了
            callback(false);
        }
    }, Math.floor(Math.random() * (3000 - 1000) + 1000));
}

let agreeGod = null; // 同意邓哥的第一个女神
const results = []; // 用于记录回复结果的数组

for (let i = 1; i <= 20; i++) {
    const god = `女神${i}`;
    biaobai(god, result => {
        results.push(result);
        if (result) {
            console.log(`${god}同意了`);
            if (agreeGod) {
                console.log(`邓哥回复${god}: 不好意思, 刚才朋友用我手机乱发的`);
            } else {
                agreeGod = god;
                console.log(`邓哥终于找到了真爱`);
            }
        } else {
            console.log(`${god}拒绝了`);
        }
        /* 日志记录应该是一块的功能模块 不应该写在这个地方, 但是若使用传统的方式来实现该需求的话, 日志记录的功能貌似也就只能写在 表白函数的回调函数中了, 向每一个女神表白后, 都要判断一下是否打印日志记录... 相对比较理想的情况应该是等到所有女神都有了返回结果之后, 再打印日志记录, 不过使用传统的方式还做不到 */
        /* [注] 这么写是错误的 */
        // if (i === 20) {
        //     console.log(`日志记录: ${results}`);
        // }
        if (results.length === 20) {
            console.log(`日志记录: ${results}`);
        }
    });
}
```

```
这个案例主要对应的是下面这个问题
    异步之间的联系：某个异步操作要等待多个异步操作的结果，对这种联系的处理，会让代码的复杂度剧增 ==> 比如该案例中的日志记录, 就需要等到其他异步操作都完成后 才能执行
```

```
8.1 这一节中, 袁老提到的每个对应的问题, 都尝试着多写了两个版本, 是在第三次开始看的时候写的, 感觉上仅仅是记住了而已, 并没有理解, 也许写出来的程序还有一些问题...
对于本节所讲的4个案例, 目的在于: 让我们理解使用之前的传统方式来解决异步处理问题时所存在的一系列问题, 多写, 多练, 多写写问题写法 和 Promise 提供的新的写法, 多对比对比, 这东西只能凭感觉来体验...
```

`使用 Promise.all 来实现`

```js
function biaobai(god) {
    return new Promise((resolve, reject) => {
        console.log(`邓哥向女神【${god}】发出了表白短信`);
        setTimeout(() => {
            if (Math.random() < 0.1) { // 同意了
                resolve(true);
            } else { // 拒绝了
                resolve(false);
            }
        }, Math.floor(Math.random() * (3000 - 1000) + 1000));
    });
}

let agreeGod = null; // 同意邓哥的第一个女神
let pros = [];

for (let i = 1; i <= 20; i++) {
    const god = `女神${i}`;
    pros.push(biaobai(god).then(result => {
        if (result) {
            console.log(`${god}同意了`);
            if (agreeGod) {
                console.log(`邓哥回复${god}: 不好意思, 刚才朋友用我手机乱发的`);
            } else {
                agreeGod = god;
                console.log(`邓哥终于找到了真爱`);
            }
        } else {
            console.log(`${god}拒绝了`);
        }
        return result;
    }));
}

// 做日志记录
Promise.all(pros).then(results => {
    console.log(`日志记录: ${results}`);
});
```

`使用 async 和 await 来实现`

```js
function biaobai(god) {
    return new Promise((resolve, reject) => {
        console.log(`邓哥向女神【${god}】发出了表白短信`);
        setTimeout(() => {
            if (Math.random() < 0.1) { // 同意了
                resolve(true);
            } else { // 拒绝了
                resolve(false);
            }
        }, Math.floor(Math.random() * (3000 - 1000) + 1000));
    });
}

let agreeGod = null; // 同意邓哥的第一个女神
let results = [];

async function handler() {
    for (let i = 1; i <= 20; i++) {
        const god = `女神${i}`;
        results.push(await biaobai(god).then(result => {
            if (result) {
                console.log(`${god}同意了`);
                if (agreeGod) {
                    console.log(`邓哥回复${god}: 不好意思, 刚才朋友用我手机乱发的`);
                } else {
                    agreeGod = god;
                    console.log(`邓哥终于找到了真爱`);
                }
            } else {
                console.log(`${god}拒绝了`);
            }
            return result;
        }));
    }
    console.log(`日志记录: ${results}`);
}

handler();
```

```
有一点小问题, 就是表白并非同时发出的, 是发一个, 然后等待回复, 然后再继续发
```

## 8.2 异步处理的通用模型

`8.2 特别重要 建议反复观看 直到能够充分理解最后一张图为止`

ES官方参考了大量的异步场景，总结出了一套异步的通用模型，该模型可以覆盖几乎所有的异步场景，甚至是同步场景。

值得注意的是，为了兼容旧系统，ES6 并不打算抛弃掉过去的做法，只是基于该模型推出一个全新的 API，使用该API，会让异步处理更加的简洁优雅。

理解该 API，最重要的，是理解它的异步模型。

```
问: promise api 有啥用?
答: Promise api 就是让异步代码 写起来感觉上 和同步代码一样
```

**1. ES6 将某一件可能发生异步操作的事情，分为两个阶段：`unsettled` 和 `settled`**

![20210417211148](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417211148.png)

- unsettled： 未决阶段，表示事情还在进行前期的处理，并没有发生通向结果的那件事
- settled：已决阶段，事情已经有了一个结果，不管这个结果是好是坏，整件事情无法逆转

事情总是从 未决阶段 逐步发展到 已决阶段的。并且，未决阶段拥有控制何时通向已决阶段的能力。

**2. ES6将事情划分为三种状态： `pending`、`resolved`、`rejected`**

- `pending`: 挂起，处于未决阶段，则表示这件事情还在挂起（最终的结果还没出来）。
- `resolved`：已处理，已决阶段的一种状态，表示整件事情已经出现结果，并是一个可以按照正常逻辑进行下去的结果。
- `rejected`：已拒绝，已决阶段的一种状态，表示整件事情已经出现结果，并是一个无法按照正常逻辑进行下去的结果，通常用于表示有一个错误。

既然未决阶段有权力决定事情的走向，因此，未决阶段可以决定事情最终的状态！

我们将 把事情变为`resolved`状态的过程叫做：**`resolve`**，推向该状态时，可能会传递一些数据。

我们将 把事情变为`rejected`状态的过程叫做：**`reject`**，推向该状态时，同样可能会传递一些数据，通常为错误信息。

**始终记住，无论是 `阶段`，还是 `状态`，是不可逆的！**

![20210417211239](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417211239.png)

**3. 当事情达到已决阶段后，通常需要进行后续处理，不同的已决状态，决定了不同的后续处理。**

- `resolved`状态：这是一个正常的已决状态，后续处理表示为 `thenable`
- `rejected`状态：这是一个非正常的已决状态，后续处理表示为 `catchable`

后续处理可能有多个，因此会形成作业队列，这些后续处理会按照顺序，当状态到达后依次执行。

![20210417211251](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417211251.png)

```
unsettled 和 settled
unsettled 就是还没有 结果数据
settled 就是已经接收到了 结果数据
```

**4. 整件事称之为Promise**

![20210417211258](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210417211258.png)

> 最新的 Promise A+ 规范如下

![20210418105433](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418105433.png)

> 理解上面的概念，对学习Promise至关重要！

[ES6 Promise的resolved深入理解](https://www.cnblogs.com/JuFoFu/p/6692055.html)

## 8.3 Promise的基本使用

**回答以下问题**
- [x] 你对 Promise 的理解

`Promise 并没有消除回调 只是通过一种特定的模式 让回调变得可控 (让异步行为变得可控)`

**本节重点**

- 掌握如何将 `unsettled` 阶段的 `Promise` 推向 `settled` 阶段
- 什么情况下是将 `Promise` 推向 `resolved` 状态
- 什么情况下是将 `Promise` 推向 `rejected` 状态

![20210510212221](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510212221.png)

`[答案] D`

```js
const pro = new Promise((resolve, reject)=>{
    // 未决阶段的处理
    // 通过调用resolve函数将Promise推向已决阶段的resolved状态
    // 通过调用reject函数将Promise推向已决阶段的rejected状态
    // resolve和reject均可以传递最多一个参数，表示推向状态的数据
})

pro.then(data=>{
    //这是thenable函数，如果当前的Promise已经是resolved状态，该函数会立即执行
    //如果当前是未决阶段，则会加入到作业队列，等待到达resolved状态后执行
    //data为状态数据
}, err=>{
    //这是catchable函数，如果当前的Promise已经是rejected状态，该函数会立即执行
    //如果当前是未决阶段，则会加入到作业队列，等待到达rejected状态后执行
    //err为状态数据
})
```

> [注意] 这里所说的 **立即执行** 指的是将事件处理函数立即推向 micro queue 必须要等到同步程序执行完后 才会执行

**细节**

1. 未决阶段的处理函数是同步的，会立即执行。
2. thenable和catchable函数是异步的，就算是立即执行，也会加入到事件队列中等待执行，并且，加入的队列是微队列
3. pro.then可以只添加thenable函数`也可以同时添加 thenable(作为第一个参数传入) 和 catchable(作为第二个参数传入)`，pro.catch可以单独添加catchable函数
4. 在未决阶段的处理函数中，如果发生未捕获的错误，会将状态推向rejected，并会被catchable捕获
5. 一旦状态推向了已决阶段，无法再对状态做任何更改
6. **Promise并没有消除回调，只是让回调`形成一种特定的模式`变得可控**

- [x] demo

`biaoBai`

```js
function biaoBai(god, callback) {
    console.log(`邓哥向女神【${god}】发出了表白短信`);
    setTimeout(() => {
        if (Math.random() < 0.1) {
            callback(true);
        } else {
            callback(false);
        }
    }, 1000);
}
```

`baiBai ==> promise`

```js
const pro = new Promise((resolve, reject) => {
    console.log(`邓哥向女神1发出了表白短信`);
    setTimeout(() => {
        if (Math.random() < 0.1) {
            resolve(true);
        } else {
            resolve(false);
        }
    }, 3000);
});
// 在 3s 前后 依次 在控制台打印 pro 查看 PromiseState 属性值的变化
// PS: 袁老师视频中使用的 chrome版本 在3s后输出的是状态是 resolved 不过版本更新后 当前输出的是 fulfilled
// 对于 fulfilled 和 resolved 这两个状态值 暂且先不作区分 理解位于一个东西即可 (实际上 它们还是有点不同的)
```

![20210418123722](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418123722.png)

```
biaoBai 转 promise
    如果女神拒绝了 那么调用的也应该是 resolve
    因为这依旧是程序的正常逻辑 出现的是一个正常的结果
    并没有出现 错误 不会影响后续程序正常逻辑的执行
    通常在出现错误的信息的时候 我们才会调用 reject 函数
    将 promise 推向 rejected 状态
```

- [x] demo

`ajax ==> promise`

```js
const pro = new Promise((resolve, reject) => {
    ajax({
        url: './data/students.json?name=李华',
        success(data) {
            resolve(data);
        },
        error(err) {
            reject(err);
        }
    });
});

pro.then((data) => {
    console.log(data);
});
```

![20210418124730](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418124730.png)

![20210418124828](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418124828.png)

```
在 封装 ajax 的内部修改 更合适
```

- [x] demo

```js
const pro = new Promise((resolve, reject) => {
    console.log('unsettled');
    resolve('dahuyou');
});

pro.then((data) => {
    console.log(data);
});
```

![20210418125451](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418125451.png)

- [x] demo

```js
const pro = new Promise((resolve, reject) => {
    console.log('unsettled');
    setTimeout(() => {
        resolve('dahuyou');
    }, 3000);
});

pro.then((data) => {
    console.log(data); // 3s 后才会打印
});
```

![20210418125655](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418125655.png)

- [x] demo

`并列的 Promise ==> 为一个 Promise 注册多个 thenable ==> 一旦该 Promise 的状态变为 resolved 那么会按照事件注册的顺序 执行多个事件`

```js
const pro = new Promise((resolve, reject) => {
    console.log('unsettled');
    setTimeout(() => {
        resolve('dahuyou');
    }, 3000);
});

pro.then((data) => {
    console.log(data + '1'); // 3s 后会同时打印
});
pro.then((data) => {
    console.log(data + '2'); // 3s 后会同时打印
});
pro.then((data) => {
    console.log(data + '3'); // 3s 后会同时打印
});
```

![20210427163239](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427163239.png)

- [x] demo

```js
const pro = new Promise((resolve, reject) => {
    console.log('unsettled');
    setTimeout(() => {
        if (Math.random() < 0.5) {
            resolve('dahuyou');
        } else {
            reject(new Error('dahuyou'));
        }
    }, 3000);
});

pro.then(data => {
    console.log('resolved');
    console.log(data + '1'); // 3s 后会同时打印
}, err => {
    console.log('rejected');
    console.log(err + '1');
});
pro.then(data => {
    console.log(data + '2'); // 3s 后会同时打印
}, err => {
    console.log(err + '2');
});
pro.then(data => {
    console.log(data + '3'); // 3s 后会同时打印
}, err => {
    console.log(err + '3');
});
```

![20210427163725](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427163725.png)

![20210427163732](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427163732.png)

```
因为 都是同一个 promise 即: 它们的状态都是一致的
所以 要么都打印 dahuyou 要么都打印 Error: dahuyou
```

- [x] demo

`在函数内部返回 promise`

```js
function biaoBai(god) { // 返回一个 promise
    return new Promise((resolve, reject) => {
        console.log(`邓哥向【${god}】发出了表白短信`);
        setTimeout(() => {
            if (Math.random() < 0.1) {
                resolve(true);
            } else {
                resolve(false);
            }
        }, 3000);
    });
}
```

```js
const pro = biaoBai('女神1');
pro.then(result => {
    console.log(result);
});
```

![20210418130644](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418130644.png)

```js
biaoBai('女神1').then(result => { // 可读性很好
    console.log(result);
});
// 向 女神1 表白 若程序逻辑正常 那么将得到的结果 result 打印
```

![20210418130723](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418130723.png)

- [x] demo

`在函数内部返回 promise`

```js
// 改写 封装好的Ajax函数
function ajax(obj) {
    return new Promise((resolve, reject) => {
        // ... 保持不变
        // 接收返回过来的数据
        xhr.onreadystatechange = function () {
            if (xhr.readyState === 4) {
                if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                    resolve(JSON.parse(xhr.responseText));
                } else {
                    reject(xhr.status);
                }
            }
        }
    });
}

// 原来的 ajax 函数 (袁老封装的ajax)
function ajax(obj) {
    // ...
    // 接收返回过来的数据
    xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
            if (xhr.status >= 200 && xhr.status < 300 || xhr.status == 304) {
                if (obj.success) {
                    // resolve
                    obj.success(JSON.parse(xhr.responseText));
                }
            } else {
                if (obj.error) {
                    // reject
                    obj.error(xhr.status);
                }
            }
        }
    }
}
```

```js
ajax({
    url: './data/students.json?name=李华'
}).then(res => {
    console.log(res);
}, err => {
    console.log(err);
});
```

![20210418131340](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418131340.png)

- [x] demo

`unsettled 阶段的程序是同步的 会立即执行`

```js
const pro = new Promise((resolve, reject) =>{
    console.log('a'); // 这里面的是同步执行的程序
});

console.log('b');
```

![20210418131818](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418131818.png)

- [x] demo

`thenable函数 和 catchable函数 是异步的 就算是立即执行 也会加入到事件队列中等待执行 并且加入的是 micro queue (微队列)`

```js
const pro = new Promise((resolve, reject) => {
    console.log('a');
    resolve('dahuyou');
    console.log('b');
});

pro.then(data => {
    console.log(data);
})
```

![20210418132050](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418132050.png)

- [x] demo

`unsettled 阶段 的 pending 状态的同步代码 和 settled 阶段的 resolved 状态 和 rejected 状态的异步代码`

```js
const pro = new Promise((resolve, reject) => {
    console.log('a'); // 同步
    resolve('dahuyou'); // 同步
    console.log('b'); // 同步
});

pro.then(data => {
    console.log(data); // 异步
})

console.log('c'); // 同步
```

![20210418132432](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418132432.png)

- [x] demo

`micro queue 优先于 macro queue`

```js
const pro = new Promise((resolve, reject) => {
    console.log('a');
    resolve('dahuyou');
    setTimeout(() => {
        console.log('b'); // 异步 -> macro queue
    }, 0);
});

pro.then(data => {
    console.log(data); // 异步 -> micro queue
})

console.log('c');
```

![20210418132557](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418132557.png)

- [x] demo

`Promise.then() 和 Promise.catch()`

```js
pro.then(data => {
    console.log(data);
}, err => {
    console.log(err);
});
```

`等价于下面的写法`

```js
pro.then(data => {
    console.log(data);
});
pro.catch(err => {
    console.log(err);
});
```

```
pro.then 可以只添加 thenable函数(仅写一个参数即可) 也可以同时添加 thenable函数 和 catchable函数(同时写两个参数即可) PS: 这些参数都是 函数
使用 pro.catch 可以只添加 catchable函数
```

- [x] demo

`在 unsettled 阶段的处理函数中 若发生了未捕获的错误 那么会将 pro 的状态推向 rejected 状态 并会被 catchable 捕获`

```js
const pro = new Promise((resolve, reject) => {
    throw new Error('抛出一个错误'); // pro -> rejected
});

pro.then(data => {
    console.log(data);
}, err => {
    console.log(err);
});
```

![20210418133329](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418133329.png)

- [x] demo

`pro 状态不可逆 无法更改`

`一旦 pro 的状态推向了 settled 状态 无法再对它的状态做任何更改`

```js
const pro = new Promise((resolve, reject) => {
    resolve(1);
    reject(2); // 无效
    resolve(3); // 无效
});

pro.then(data => {
    console.log(data);
}, err => {
    console.log(err);
});
```

![20210418133547](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418133547.png)

- [x] demo

`未捕获的错误 会将 promise 推向 settled 阶段`

```js
const pro = new Promise((resolve, reject) => {
    throw new Error('抛出一个错误'); // pro -> rejected
    resolve(1); // 无效
});

pro.then(data => {
    console.log(data);
}, err => {
    console.log(err);
});
```

![20210418133731](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418133731.png)

- [x] demo

`捕获的错误 并不会将 promise 推向 settled 阶段`

```js
const pro = new Promise((resolve, reject) => {
    try {
        throw new Error('抛出一个错误');
    } catch {
        console.log('捕获到了错误');
    }
    resolve(1); // 有效 因为上面的错误被捕获了 并没有将 pro 的状态推向 rejected
});

pro.then(data => {
    console.log(data);
}, err => {
    console.log(err);
});
```

![20210418133936](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418133936.png)

- [x] demo

```js
const pro = new Promise((resolve, reject) => {
    const a = 1;
    a = 2; // 在 Promise 构造函数的参数方法中 代码报错 ==> 会将该 Promise 推向 rejected 状态
});

pro.then(result => {
    console.log(result);
});

pro.catch(err => {
    console.log(err);
});
```

![20210510220730](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510220730.png)

## 8.4 Promise的串联

- [x] demo

```js
ajax({
    url: './data/students.json'
}).then(stus => {
    for (let i = 0; i < stus.length; i++) {
        const stu = stus[i];
        if (stu.name === '李华') {
            const cid = stu.classId;
            console.log(`拿到李华所在的班级id: ${cid}`);
            ajax({
                url: './data/classes.json'
            }).then(cls => {
                for (let i = 0; i < cls.length; i++) {
                    const cl = cls[i];
                    if (cl.id === cid) {
                        const tid = cl.teacherId;
                        console.log(`拿到班级id为: ${cid} 的老师id: ${tid}`);
                        ajax({
                            url: './data/teachers.json'
                        }).then(ts => {
                            for (let i = 0; i < ts.length; i++) {
                                const t = ts[i];
                                if (t.id === tid) {
                                    console.log(`拿到老师id为: ${tid} 的老师信息: `, t);
                                }
                            }
                        });
                    }
                }
            });
        }
    }
});
```

![20210510222246](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510222246.png)

```
试着用目前所学到的内容, 尝试重新写一遍 回调地狱 3 的那个 demo, 我们会发现 即便使用现阶段所学的 Promise的相关知识点, 依旧没有解决 8.1 中提及的 回调地狱 的问题
```

- [x] demo

`并列的 thenable`

```js
const pro = ajax({
    url: './data/students.json'
});

// 获取指定学生信息
pro.then(stus => {
    stus.forEach(stu => {
        if (stu.name === '李华') {
            console.log(`获取到的李华学生信息如下:`);
            console.log(stu);
        }
    });
});

// 获取所有的女生
pro.then(stus => {
    const newArr = stus.filter(stu => stu.gender === '女');
    console.log(`获取到的所有女生信息如下:`);
    console.log(newArr);
});

// 获取所有年龄在 20 岁以下的学生信息
pro.then(stus => {
    const newArr = stus.filter(stu => stu.age < 20);
    console.log(`获取到的所有年龄在 20岁 以下的学生信息如下:`);
    console.log(newArr);
});
```

![20210510222713](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210510222713.png)

`下图是thenable接收到的参数 stus 中的数据`

![20210418150543](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418150543.png)


```
并列的 promise
    上面涉及到的是 同一个 promise 的并列操作
    - 获取指定学生信息
    - 获取所有的女生
    - 获取所有年龄在 20 岁以下的学生信息
    这3个需求 是并列进行的 它们之间并没有什么先后关系
    即: 后续操作不需要依赖前面操作得到的结果数据
串联的 promise
    但是在 8.1 的案例中 我们的需求是由先后关系的
    1. 先获取到指定学生信息
    2. 通过学生信息获取到指定班级信息
    3. 通过班级信息获取到指定老师信息
    即: 后续操作需要依赖前面操作得到的结果数据
```

当后续的Promise需要用到之前的Promise的处理结果时，需要Promise的串联

Promise对象中，无论是then方法还是catch方法，它们都具有返回值，返回的是一个全新的Promise对象，它的状态满足下面的规则：

1. 如果当前的Promise是未决`unsettled`的，得到的新的Promise是挂起状态`pending`
2. 如果当前的Promise是已决`settled`的，会运行相应的后续处理函数`若没有相应的后续处理函数来处理 那么返回的新的 Promise 对象的状态和数据都将与 当前的 Promise 对象保持一致`，并将后续处理函数的结果（返回值）作为`resolved`状态数据，应用到新的Promise中；**如果后续处理函数发生错误**，则把返回值作为`rejected`状态数据，应用到新的Promise中。

> then 返回的 promise 对象 一开始一定是 pending 状态 `因为 then 中的程序是异步的, 要等到这些异步的程序有了执行结果之后, 返回的 Promise 对象才会被推向 settled 阶段; 但是并非 要等到前面的 Promise 有了处理结果才会返回 Promise 对象, 只要执行到 Promise.then() 语句时, 就会返回 Promise 对象, 即便 then 里面的异步程序都还没有开始执行, 即: 前一个Promise还没处理完, 没有返回处理结果; 所以说 then 返回的 Promise 对象一开始一定是 pending 状态, 因为里面的异步程序还没执行`
> **重点: unsettled 阶段的 pending 状态的程序是同步执行的。**

**后续的Promise一定会等到前面的Promise有了后续处理结果后，才会变成已决状态**

如果前面的Promise的后续处理，返回的是一个Promise，则返回的新的Promise状态和后续处理返回的Promise状态保持一致。


- [x] demo

`then 返回的 promise 对象一开始一定是 pending 状态`

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
});
console.log(pro1);
const pro2 = pro1.then(result => result * 2);
console.log(pro2);
/* 输出的 pro2
类型是: promise对象
状态是: pending
    因为输出pro2时 pro1.then 中的异步程序还没有开始执行
    要等到 pro1.then 中的异步程序执行完后 也就是 pro1 有了处理结果后 pro2 的状态才会变为 resolved 并且 pro1 的处理结果将作为 pro2 的状态数据传入
 */
pro2.then(result => console.log(result), err => console.log(err)); // 2
```

![20210511170805](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210511170805.png)

```
在执行同步语句 console.log(pro2); 时 pro1.then(result => result * 2); 中的异步语句 result => result * 2 还没有执行 即: pro1.then 还没有得到一个处理结果
```

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
});

const pro2 = pro1.then(result => result * 2);
console.log(pro2);

setTimeout(() => {
    console.log(pro2);
}, 0);
```

![20210426144856](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210426144856.png)

```
pro1.then() 返回的 promise 对象的状态会 动态更新 并不是一成不变的 只要 pro1.then() 有了处理结果 那么它返回的 promise 对象的状态就会变为 settled 阶段
```

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    throw 1; // A 出错了
});

const pro2 = pro1.then(result => result * 2, err => err * 3); // B 没有出错
// 因为 A 出错了 所以 B 运行 catchable 即: err => err * 3

pro2.then(result => console.log(result * 2), err => console.log(err * 3)); // C
// 因为 B 没有出错 所以 C 运行 thenable 即: result => console.log(result * 2)
```

![20210426145929](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210426145929.png)

```
const promise1 = new Promise((resolve, reject) => {
    // ... pending 阶段的事件处理程序
});
promise2 = promise1.then(thenable, catchable);

promise1 和 promise2 的状态分析

promise1 的状态 取决于 在 pending 阶段的事件处理程序中 执行的是 resolve() 还是 reject() 还是 抛出了错误
    执行 resolve() ==> promise1 变为 resolved 状态 ==> 执行 thenable
    执行 reject() 或 抛出错误 ==> promise1 变为 rejected 状态 ==> 执行 catchable
promise2 的状态 取决于 promise1.then() 执行是否抛出了错误
    没有抛出错误 ==> promise2 变为 resolved 状态
    抛出了错误 ==> promise2 变为 rejected 状态
```

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    throw 1;
});

const pro2 = pro1.then(result => result * 2, err => {
    throw err;
} );

pro2.then(result => console.log(result * 2), err => console.log(err * 3)); // 3
```

![20210418165448](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418165448.png)

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    throw 1;
});

const pro2 = pro1.then(result => result * 2, err => {
    throw err;
});

pro2.catch(err => err * 5);

pro2.then(result => console.log(result * 3), err => console.log(err * 4)); // 4
```

![20210418170013](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418170013.png)

```
pro2.catch();
pro2.then();
// 注意: 最后两个条语句 它们是并列关系 两者之间互不影响 并不会出现覆盖的情况
```

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    throw 1;
});

const pro2 = pro1.then(result => result * 2, err => {
    console.log(err); // 1
    throw err;
});

pro2.catch(err => {
    console.log(err * 5); // 5
});

pro2.then((result) => {
    console.log(result * 3);
}).catch((err) => {
    console.log(err * 4); // 4
});
```

![20210511173650](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210511173650.png)

```
两者之间是并列关系 并不会出现覆盖的情况
```

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    throw 1;
});

const pro2 = pro1.then(result => result * 2, err => {
    console.log(err); // 1
    throw err * 2;
});

pro1.catch(err => {
    console.log(err); // 1
    throw err;
});

pro2.then((result) => {
    console.log(result * 3);
}).catch((err) => {
    console.log(err * 4); // 8
});
```

```
两者之间是并列关系 并不会出现覆盖的情况
```

- [x] demo

`在 thenable 或 catchable 中返回的是一个 promise 对象`

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
});

const pro2 = new Promise((resolve, reject) => {
    resolve(2);
});

const pro3 = pro1.then(result => {
    return pro2;
});

console.log(pro3); // Promise {<pending>}
console.log(pro3 === pro2); // false

pro3.then(result => {
    console.log(result === pro2); // false
    console.log(result); // 2
});

pro2.then(result => {
    console.log(result * 2); // 2
});
```

![20210511174500](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210511174500.png)

`如果前面的Promise的后续处理，返回的是一个Promise，则返回的新的Promise状态和后续处理返回的Promise状态保持一致。`

```
这句话指的是 pro3 的状态 与 pro2 的状态保持一致
    当 pro2 的状态变为 resolved 之后 pro3 才会变为 resolved
    当 pro2 的状态变为 rejected 之后 pro3 才会变为 rejected
    并且两者的参数还相同
[注] 一定是 pro2 先发生状态变化, pro3 后发生状态变化, 所以我们会看到, 控制台中先打印的是 4, 后打印的是 2
```

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
});

const pro2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(2);
    }, 3000);
});

const pro3 = pro1.then(result => {
    return pro2;
});

pro3.then(result => {
    console.log(result); // 2
});
```

```
3s 后 会在控制台打印 2
虽然 pro1.then() 很快就返回了一个处理结果 按理来说 pro3 在 pro1.then() 得到一个处理结果后 就将变为 settled 阶段; 但是这里有点特殊, 因为返回的是一个 promise 对象 pro2, 所以 pro3 的状态将由 pro2 来决定, 只有当 pro2 的变为 settled 阶段 pro3 才会变为 settled 阶段
```

- [x] demo

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
});

const pro2 = new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(2);
    }, 3000);
});

pro1.then(result => {
    console.log(1); // 1
    return pro2;
}).then(result => { // 要等到 pro2 变为 resolved 状态之后 才会执行
    console.log(result); // 2
    // return undefined; // 没有写 return 默认返回 undefined
}).then(result => {
    console.log(result); // undefined
});
```

![20210418171922](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418171922.png)

```
立即打印 1
过 3s 后 打印 2 和 undefined
因为第二个 then 中并没有 指定 return 的返回值
所以 return 默认值 undefined
```

**下面开始尝试使用串联的 Promise 来重写 8.1 中的 demo3**

- [x] bug

`经典的 错误写法... 为什么控制台啥也没打印`

```js
const pro = ajax({
    url: './data/students.json'
});

// 查找李华的老师信息
pro.then(res => {
    let cId = null; // 班级id

    // 给 cId 赋值
    res.forEach(stu => {
        if (stu.name === '李华') {
            cId = stu.classId;
        }
    });

    return cId; // 作为下一次的 thenable 参数传入
}).then(cId => {
    let tId = null; // 老师id

    // 给 tId 赋值
    ajax({
        url: './data/classes.json?classId=' + cId
    }).then(classRoom => {
        classRoom.forEach(c => {
            if (c.id === cId) {
                tId = c.teacherId;
            }
        });
        // console.log(tId);
    });

    // console.log(tId);
    return tId;
}).then(tId => {
    ajax({
        url: './data/teachers.json?teacherId=' + tId
    }).then(teacher => {
        teacher.forEach(t => {
            if (t.id === tId) {
                console.log(t);
            }
        });
    });
});
```

```
这个 bug 的原因其实是由于 异步函数 所导致的
将这段程序中的两条被注释掉的打印语句 console.log(tId); 取消掉注释
会发现控制台先输出的将会是 下面一行打印语句输出的 tId 结果为 null
相对于第二次调用 ajax 而言 代码 let tId = null; 和 return tId; 是同步执行的; 而 ajax().then(...) 中的 thenable程序是异步执行的

[原因分析] ajax().then(异步执行的程序) then方法中的程序是异步执行的
```

`执行顺序分析`

```js
const pro = ajax({
    url: './data/students.json'
});

// 查找李华的老师信息
pro.then(res => {
    let cId = null; // 班级id

    // 给 cId 赋值
    res.forEach(stu => {
        if (stu.name === '李华') {
            cId = stu.classId;
        }
    });

    return cId; // 作为下一次的 thenable 参数传入
}).then(cId => {
    let tId = null; // 老师id

    console.log(1);

    ajax({
        url: './data/classes.json?classId=' + cId
    }).then(classRoom => {

        console.log(5);

        classRoom.forEach(c => {
            if (c.id === cId) {
                tId = c.teacherId;
            }
        });
    });

    console.log(2);

    return tId;
}).then(tId => {

    console.log(3);

    ajax({
        url: './data/teachers.json?teacherId=' + tId
    }).then(teacher => {

        console.log(6);

        teacher.forEach(t => {
            if (t.id === tId) {
                console.log(t);
            }
        });
    });

    console.log(4);
});
```

![20210420174402](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210420174402.png)

- [x] debug - 1 `then 方法返回的不是一个 promise 对象`

```js
const pro = ajax({
    url: './data/students.json'
});

// 查找李华的老师信息
pro.then(res => {
    let cId = null; // 班级id

    // 给 cId 赋值
    res.forEach(stu => {
        if (stu.name === '李华') {
            cId = stu.classId;
        }
    });

    return cId; // 作为下一次的 thenable 参数传入
}).then(cId => {

    ajax({
        url: './data/classes.json?classId=' + cId
    }).then(classRoom => {
        let tId = null; // 老师id

        // 给 tId 赋值
        classRoom.forEach(c => {
            if (c.id === cId) {
                tId = c.teacherId;
            }
        });

        return tId;
    }).then(tId => {

        ajax({
            url: './data/teachers.json?teacherId=' + tId
        }).then(teacher => {
            teacher.forEach(t => {
                if (t.id === tId) {
                    console.log(t);
                }
            });
        });

    });
});
```

![20210418154035](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418154035.png)

```
这么做虽然获取到了想要的结果, 但是还是会陷入回调地狱;
```

- [x] debug - 2 `then 方法返回的是一个 promise 对象`

```
PS: 此时没用调通 最终控制台输出的结果是 undefined 试分析原因...
```

```js
const pro = ajax({
    url: './data/students.json'
});

// 查找李华的老师信息
pro.then(res => {
    res.forEach(stu => {
        if (stu.name === '李华') {
            return stu.classId; // 将学生对应的班级id返回 作为一下次处理函数的参数传入
        }
    });
}).then(cId => {
    return ajax({
        url: './data/classes.json?classId=' + cId
    }).then(classRoom => {
        classRoom.forEach(c => {
            if (c.id === cId) {
                return c.teacherId; // 将班级对应的老师id返回 作为一下次处理函数的参数传入
            }
        });
    });
}).then(tId => {
    return ajax({
        url: './data/teachers.json?teacherId=' + tId
    }).then(teacher => {
        teacher.forEach(t => {
            if (t.id === tId) {
                return t; // 将老师信息返回 作为一下次处理函数的参数传入
            }
        });
    });
}).then(tInfo => {
    console.log(tInfo); // undefined
});
```

```
forEach 它也是一个函数, 所以 return 不能在 forEach 这个函数里面 return
```

- [x] debug - 3

`把 forEach 改成 for 循环即可`

```js
const pro = ajax({
    url: './data/students.json'
});

// 查找李华的老师信息
pro.then(res => {
    for (let i = 0; i < res.length; i++) {
        const stu = res[i];
        if (stu.name === '李华') {
            return stu.classId; // 将学生对应的班级id返回 作为一下次处理函数的参数传入
        }
    }
}).then(cId => {
    return ajax({
        url: './data/classes.json?classId=' + cId
    }).then(classRooms => {
        for (let i = 0; i < classRooms.length; i++) {
            const c = classRooms[i];
            if (c.id === cId) {
                return c.teacherId; // 将班级对应的老师id返回 作为一下次处理函数的参数传入
            }
        }
    });
}).then(tId => {
    return ajax({
        url: './data/teachers.json?teacherId=' + tId
    }).then(teachers => {
        for (let i = 0; i < teachers.length; i++) {
            const t = teachers[i];
            if (t.id === tId) {
                return t; // 将老师信息返回 作为一下次处理函数的参数传入
            }
        }
    });
}).then(tInfo => {
    console.log(tInfo); // {id: 2, name: "张", gender: "女"}
});
```

```
这种写法实际上还可以进一步简化 不过得掌握后续的更多知识点之后 才能实现...
```

- [x] demo

`用 promise 来实现 8.1 的 demo2`

```
需求描述:
    场景:
      邓哥心中有三个女神
      有一天，邓哥决定向第一个女神表白
      如果女神拒绝，则向第二个女神表白
      直到所有的女神都拒绝 或 有一个女神同意为止
      表白的时间间隔为 1s
    用代码模拟上面的场景
```

```js
function biaoBai(god) {
    return new Promise((resolve, reject) => {
        console.log(`邓哥向${god}发出了表白短信`);
        setTimeout(() => {
            if (Math.random() < 0.1) {
                resolve(true); // 女神同意了
            } else {
                resolve(false); // 女神拒绝了
            }
        }, 1000); // 等 1s 后再决定该 promise 的状态
    });
}

biaoBai('女神1').then(result => {
    if (result === true) {
        console.log('女神1同意了 停止表白');
        return;
    } else {
        console.log('女神1拒绝了 继续向女神2表白');
        return biaoBai('女神2');
    }
}).then(result => {
    if (result === undefined) { // 女神1同意了 接下来啥也不做
        return;
    } else if (result === true) {
        console.log('女神2同意了 停止表白');
        return;
    } else {
        console.log('女神2拒绝了 继续向女神3表白');
        return biaoBai('女神3');
    }
}).then(result => {
    if (result === undefined) { // 女神1 或 女神2 同意了 接下来啥也不做 (result === undefined 表示在此之前已经有女神同意了)
        return;
    } else if (result === true) {
        console.log('女神3同意了 停止表白');
    } else {
        console.log('女神3拒绝了 全都拒绝了');
    }
});
```

![20210418183744](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418183744.png)

![20210418183816](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418183816.png)

```
下一个 then 执行所接收的参数 主要看前一个 then 的return 是啥
这个案例中 return 只有两种情况
    1. undefined
    2. Promise -> 注意 返回的 promise 对象 并非作为后续的 then 的数据
假设
    女神1 同意了
    那么 程序执行的时间大致在 1s 左右, 因为之后的 then 接收到的都是 undefined 返回的也都是 undefined
同理
    女神1 拒绝 女神2 同意 执行 2s 左右
    女神1 和 女神2 都拒绝 执行 3s 左右
```

- [x] demo

**思考:**

`pro = pro.then(...)` 为什么这么写就能实现 pro 的串联, pro 变量明明就只有一个, 重复赋值 为什么不会覆盖前面的值?

`简化版 提取公共 code 用for循环来实现`

```js
// const godsArr = ['女神1', '女神2', '女神3'];
const godsArr = ['女神1', '女神2', '女神3', '女神4', '女神5'];
let pro;

for (let i = 0; i < godsArr.length; i++) {
    const god = godsArr[i];
    if (i === 0) { // 第一次进入循环 先确保变量 pro 存放的是一个 promise 对象
        pro = biaoBai(god);
    }
    pro = pro.then(result => {
        if (result === true) {
            console.log(`${god}同意了 停止表白`);
            return;
        } else if (result === undefined) { // 已经有女神同意了 接下来啥也不做
            return;
        } else {
            if (god !== godsArr[godsArr.length - 1]) {
                console.log(`${god}拒绝了 继续向${godsArr[i + 1]}表白`);
                return biaoBai(godsArr[i + 1]);
            } else {
                console.log(`${god}拒绝了 全都拒绝了`);
            }
        }
    });
}
```

![20210418185355](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418185355.png)

```
先执行完的 肯定是 for 循环 执行完 for 循环后 相当于创建了下面这样的 'promise 链条', 该链条仅仅是创建好了, 但是then中的异步程序的执行 并不是在创建好后 就立即执行的
```

```js
biaoBai('女神1').then(result => {
    if (result === true) {
        console.log('女神1同意了 停止表白');
        return;
    } else {
        console.log('女神1拒绝了 继续向女神2表白');
        return biaoBai('女神2');
    }
}).then(result => {
    if (result === undefined) {
        return;
    } else if (result === true) {
        console.log('女神2同意了 停止表白');
        return;
    } else {
        console.log('女神2拒绝了 继续向女神3表白');
        return biaoBai('女神3');
    }
}).then(result => {
    if (result === undefined) {
        return;
    } else if (result === true) {
        console.log('女神3同意了 停止表白');
    } else {
        console.log('女神3拒绝了 继续向女神4表白');
        return biaoBai('女神4');
    }
}).then(result => {
    if (result === undefined) {
        return;
    } else if (result === true) {
        console.log('女神4同意了 停止表白');
    } else {
        console.log('女神4拒绝了 继续向女神5表白');
        return biaoBai('女神5');
    }
}).then(result => {
    if (result === undefined) {
        return;
    } else if (result === true) {
        console.log('女神5同意了 停止表白');
    } else {
        console.log('女神5拒绝了 全都拒绝了');
    }
});
```

```
每次 pro 被赋予的都是一个 promise 对象 ———— 由上一个 pro.then 返回的全新的 promise 对象, 所以 并不会出现覆盖的情况
问: 表白结束后 pro 的状态和值分别是什么?
答: resolved undefined
```

- [ ] `补充`

`注意下面这句话, 在手写 Promise 那一节的最后一个视频中讲的 bug 就是该问题`

如果当前的Promise是已决`settled`的，会运行相应的后续处理函数`若没有相应的后续处理函数来处理 那么返回的新的 Promise 对象的状态和数据都将与 当前的 Promise 对象保持一致`

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
});

const pro2 = pro1.catch(err => {
    console.log(err); // 并不会执行
});

console.log(pro2 === pro1); // false
/*
pro1 和 pro2 的状态都是 resolved(fulfilled) 状态, 状态数据都是 1
*/

pro2.then(data => {
    console.log(data); // 1
});
```

## 8.5 Promise的其他api

**原型成员 (实例成员)**
- `then`：注册一个后续处理函数，当Promise为resolved状态时运行该函数 `也可以同时注册两个事件处理函数`
- `catch`：注册一个后续处理函数，当Promise为rejected状态时运行该函数
- `finally`：[ES2018]注册一个后续处理函数（无参），当Promise为已决`settled`时运行该函数

- [x] demo

```js
const pro = new Promise((resolve, reject) => {
    resolve(1);
});

pro.finally(() => console.log('finilly1'));
pro.finally(() => console.log('finilly2'));
pro.then(result => console.log(`then1 ${result * 1}`));
pro.then(result => console.log(`then1 ${result * 2}`));
pro.catch(result => console.log(`catch1 ${result * 2}`));
pro.catch(result => console.log(`catch1 ${result * 2}`));
pro.finally(() => console.log('finilly3'));
pro.finally(() => console.log('finilly4'));
```

![20210418201452](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418201452.png)

```
finally 写在前面就在前面执行
finally 写在后面就在后面执行
```

**构造函数成员 （静态成员）**

- resolve(数据)：该方法返回一个resolved状态的Promise，传递的数据作为状态数据
  - 特殊情况：如果传递的数据是Promise，则直接返回传递的Promise对象 `这一规则 (不需要记), 因为 不同浏览器会有所不同 该特殊情况适用于 chrome`
- reject(数据)：该方法返回一个rejected状态的Promise，传递的数据作为状态数据

- [x] demo

`Promise.resolve()`

```js
const pro = new Promise((resolve, reject) => {
    resolve(1);
});
console.log(pro);
```

`等价于`

```js
const pro = Promise.resolve(1);
console.log(pro);
```

![20210418201821](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418201821.png)

- [x] demo

`Promise.reject()`

```js
const pro = new Promise((resolve, reject) => {
    reject(1);
});
console.log(pro);
```

`等价于`

```js
const pro = Promise.reject(1);
console.log(pro);
```

![20210418202021](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418202021.png)

- [x] demo

`特殊情况 Promise.resolve(promise)`

```js
const p = new Promise((resolve, reject) => {
    resolve(3);
});

const pro = Promise.resolve(p); // 等效于 const pro = p;
console.log(p);
console.log(pro);
console.log(pro === p); // true
/*
[注]
const pro = Promise.resolve(p);
此时就不再是等价于下面这种写法了
const pro = new Promise((resolve, reject) => {
    resolve(p);
});
*/
```

![20210418202537](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418202537.png)

- all(iterable)：这个方法返回一个新的promise对象，该promise对象在iterable参数对象里所有的promise对象都成功的时候才会触发成功，一旦有任何一个iterable里面的promise对象失败则立即触发该promise对象的失败。这个新的promise对象在触发成功状态以后，会把一个包含iterable里所有promise返回值的数组作为成功回调的返回值，顺序跟iterable的顺序保持一致；如果这个新的promise对象触发了失败状态，它会把iterable里第一个触发失败的promise对象的错误信息作为它的失败错误信息。Promise.all方法常被用于处理多个promise对象的状态集合。

> `iterator` 是后续的 `10. 迭代器与生成器` 介绍的知识点

- [x] demo

```js
function getRandom(min, max) {
    return Math.round(Math.random() * (max - min) + min);
}

const pros = [];

for (let i = 0; i < 10; i++) {
    pros.push(new Promise((resolve, reject) => {
        setTimeout(() => {
            console.log(`${i} 已完成`);
            resolve(`${i} 已完成`);
        }, getRandom(1000, 5000));
    }));
}

// console.log(pros); // 这里会立刻打印10个Promise

const pro = Promise.all(pros);

pro.then(result => {
    console.log(`全部已完成 ==> `, result);
});
```

![20210418203711](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418203711.png)

- [x] demo

`8.1 demo4 实现日志记录功能`

```js
function biaoBai(girl) {
    return new Promise((resolve, reject) => {
        setTimeout(() => { // 每次表白的时刻在 1~3s 不等 实现乱序表白
            console.log(`正在向${girl}表白`);
            if (Math.random() < 0.1) { // 1/10 的可能性同意
                console.log(girl, '同意了');
                resolve(true);
            } else {
                console.log(girl, '拒绝了');
                resolve(false);
            }
        }, Math.round(Math.random() * (3000 - 1000) + 1000));
    });
}

const pros = [];

for (let i = 0; i < 20; i++) {
    pros.push(biaoBai(`女神${i}`));
}

Promise.all(pros).then(results => {
    console.log(`日志记录为: `, results);
});
```

- [x] demo

`一旦有失败的 则立即将 Promise.all() 返回的新的 promise 对象推向 rejected 状态`

```js
function biaoBai(girl) {
    return new Promise((resolve, reject) => {
        setTimeout(() => { // 每次表白的时刻在 1~3s 不等 实现乱序表白
            console.log(`正在向${girl}表白`);
            if (Math.random() < 0.1) { // 1/10 的可能性同意
                console.log(girl, '同意了');
                resolve(true);
            } else {
                console.log(girl, '拒绝了');
                reject('作为Promise.all().catch() 的参数传入');
            }
        }, Math.round(Math.random() * (3000 - 1000) + 1000));
    });
}

const pros = [];

for (let i = 0; i < 20; i++) {
    pros.push(biaoBai(`女神${i}`));
}

Promise.all(pros).catch(err => {
    console.log('出现了失败的, 最终将不会输出日志记录, 接收到的参数为: ', err);
});
Promise.all(pros).then(results => {
    console.log(`日志记录为: `, results);
});
```

- race(iterable)：当iterable参数里的任意一个子promise被成功或失败后，父promise马上也会用子promise的成功返回值或失败详情作为参数调用父promise绑定的相应句柄，并返回该promise对象

- [x] demo

`Promise.race()`

```js
function biaoBai(girl) {
    return new Promise((resolve, reject) => {
        setTimeout(() => { // 每次表白的时刻在 1~3s 不等 实现乱序表白
            console.log(`正在向${girl}表白`);
            if (Math.random() < 0.1) { // 1/10 的可能性同意
                console.log(girl, '同意了');
                resolve(true);
            } else {
                console.log(girl, '拒绝了');
                reject(false);
            }
        }, Math.round(Math.random() * (3000 - 1000) + 1000));
    });
}

const pros = [];

for (let i = 0; i < 3; i++) {
    pros.push(biaoBai(`女神${i}`));
}

Promise.race(pros).catch(err => {
    console.log('已经有女神回复的, 回复的结果是: ', err);
});
Promise.race(pros).then(result => {
    console.log(`已经有女神回复的, 回复的结果是: `, result);
});
```

- [x] demo

`8.1 demo4`

```js
function biaoBai(girl) {
    return new Promise((resolve, reject) => {
        setTimeout(() => { // 每次表白的时刻在 1~3s 不等 实现乱序表白
            console.log(`正在向${girl}表白`);
            if (Math.random() < 0.1) { // 1/10 的可能性同意
                console.log(`${girl}同意了`);
                resolve(true);
            } else {
                console.log(`${girl}拒绝了`);
                resolve(false);
            }
        }, Math.round(Math.random() * (3000 - 1000) + 1000));
    });
}

const pros = [];
let hasAgree = false;

for (let i = 0; i < 20; i++) {
    pros.push(biaoBai(`女神${i}`).then(result => {
        if (result) {
            if (hasAgree) {
                console.log(`滚... 邓哥已经找到了`);
            } else {
                hasAgree = true;
                console.log(`邓哥终于找到了...`);
            }
        }
        return result;
    }));
}

Promise.all(pros).then(results => {
    console.log('日志记录: ', results);
})
```

## 8.6 [扩展]手写Promise

**参考文章**

[JS Promise 掘金](https://juejin.cn/post/6945319439772434469)

- [ ] 奇葩的面试题

`看不懂`

```js
Promise.resolve().then(() => {
    console.log(0);
    return Promise.resolve(4);
}).then((res) => {
    console.log(res)
})

Promise.resolve().then(() => {
    console.log(1);
}).then(() => {
    console.log(2);
}).then(() => {
    console.log(3);
}).then(() => {
    console.log(5);
}).then(() =>{
    console.log(6);
});
```

> 输出: 0 1 2 3 4 5 6

**手写 Promise 的要求**

```
尽可能的模拟官方 promise 的功能
```

![20210418210908](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210418210908.png)

`Promise A+ 规范`

![20210512215715](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210512215715.png)

### 8.6.1 状态控制

`8.6.1 实现的是 unsettled -> settled 阶段的事情`

![20210512215919](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210512215919.png)

`Promise A+ 规范`

![20210512220012](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210512220012.png)

```
unsettled 阶段要做的事情很简单 就是把 promise 对象推向 settled 阶段即可
这就是 executor 要做的事情
```

**notes**

- promise 对象共 2 个阶段 3 个状态

```
unsettled 阶段的 pending 状态
settled 阶段的 resolved 状态 和 rejected 状态
```

- 刚创建的 promise 对象 默认处于的是 `unsettled` 阶段的 `pending` 状态

```
处于 pending 状态的 promise 对象身上的状态数据 (即: [[PromiseResult]]) 是 undefined
```

- 在调用 Promise 构造函数来创建 promise 对象的时候，仅传入一个参数，并且该参数也是一个函数，这个函数接收两个参数，分别是  `resolve` `reject` (通常起这名儿) 并且这两个参数本身也是函数

```
new Promise((resolve, reject) => {
    // ...
    resolve(数据);
    // ...
    reject(数据);
    // ...
});

设: 调用构造函数 Promise 时传入的参数是 executor 函数
则: executor 函数体内容如下
    (resolve, reject) => {
        // ...
        resolve(数据);
        // ...
        reject(数据);
        // ...
    }
executor 函数一共接收两个参数: resolve函数 和 reject函数
[注]
    1. executor 函数的函数体是在调用构造函数 Promise 的时候定义好的, 我们在封装 MyPromise 的时候, 只需要在内部执行一下 executor(resolve, reject) 语句即可;
    2. 但是 resolve 和 reject 函数的函数体是内部帮我们定义好的, 在调用 Promise 构造函数的时候, 我们仅仅是调用了内部帮我们定义好的 resolve 和 reject 函数;
       所以 我们在封装 MyPromise 的时候, 内部要提前定义好两个函数: resolve 和 reject, 等待用户使用我们封装的类 MyPromise 来创建 Promise 实例对象的时候调用它们;
```

- `resolve` 和 `reject` 这两个函数的作用

```
若 pending 状态下 先执行了 resolve
    该 promise 对象将自动跳转至 settled 阶段 的 resolved 状态
    Promise 的状态数据 [[PromiseResult]] 就是调用 resolve 时所传入的数据
若 pending 状态下 先执行了 reject (或者抛出了错误)
    该 promise 对象将自动跳转至 settled 阶段 的 rejectd 状态
    Promise 的状态数据 [[PromiseResult]] 就是调用 reject 时所传入的数据 (或者是错误信息)

[细节] 我们在内部实现 resolve 和 reject 函数时, 只需要考虑第一个参数即可, 如果用户调用这俩函数的时候, 数据传多了, 那也不会报错(官方的Promise就不会报错), 我们只管第一个就好
```

- promise 对象的状态变化是不可逆的

```
只有处于 unsettled 阶段下的 pending 状态的 promise 对象才可以发生状态的改变
并且只能变为 settled 阶段下的 resolved 状态 或 rejected 状态
```

- [x] `unsettled -> settled`

```js
const MyPromise = (() => {
    // 3个状态值
    const PENDING = 'pending';
    const RESOLVED = 'resolved';
    const REJECTED = 'rejected';
    // 符号成员
    const PromiseValue = Symbol('PromiseValue'); // 状态数据
    const PromiseStatus = Symbol('PromiseStatus'); // 当前状态值
    const changeStatus = Symbol('changeStatus'); // 改变当前状态

    return class {

        /**
         * @param {*} executor unsettled阶段 (即: pending状态下) 的处理函数
         */
        constructor(executor) {
            this[PromiseStatus] = PENDING; // promise 开始时的默认状态时 pending 状态
            this[PromiseValue] = undefined; // promise 的 value 默认是 undefined

            // resolve 函数 和 reject 函数 都只接收一个参数
            const resolve = data => { // 注意一下 this 的指向问题
                this[changeStatus](RESOLVED, data);
            }

            const reject = reason => {
                this[changeStatus](REJECTED, reason);
            }

            // 若 executor 在执行过程中出现了错误 那么执行 reject 函数 将promise的推向 settled 阶段的 rejected 状态 并将错误信息当做 reject 函数的参数传入
            try {
                executor(resolve, reject);
            } catch (err) {
                reject(err);
            }
        }

        /**
         * 改变 promise 的状态
         * @param {String} newStatus 新的状态
         * @param {*} newValue 新的值
         */
        [changeStatus](newStatus, newValue) {
            if (this[PromiseStatus] !== PENDING) { // 若当前的 promise 状态不是 pending 那么 它就处于 settled 阶段 那么它的状态已经是 resolved 或 rejected 了 处于这两个状态的 promise 对象 的状态是无法变更的
                // 状态无法变更
                return;
            } else { // 若当前的 promise 处于 pending状态 那么将根据调用的是 resolve 函数 还是 reject 函数 来确定它在 settled 阶段的状态是 resolved 还是 rejected 并同时把传递的参数也给带上
                this[PromiseStatus] = newStatus;
                this[PromiseValue] = newValue;
            }
        }
    }
})();
```

```
在立即执行函数中返回一个类表达式
利用闭包 防止变量污染全局
在 constructor 中定义 resolve 和 reject 的时候
若不使用 箭头函数 而是使用函数表达式来写 const resolve = function() {...} 那么 函数体中的 this指向将出问题 指向的是 undefined (非严格模式下为 window)
因为如果使用这种函数表达式的方式来实现的话 那么 函数体中的 this 指向是在函数被调用的时候才确定的
但是如果是使用箭头函数的方式来实现, 那么就可以实现和外层的 this 指向保持一致
executor 的两个参数 (也是两个函数) 是在外部空调用的
    空调用也就是直接调用 而不是通过 对象.方法名() 的形式来调用
        像是下面这样的写法 就叫空调用
            参数1()
            参数2()
        像是下面这样的写法 就不是空调用
            obj.fun()
```

**测试**

- [x] `刚初始化一个 promise 对象时 它的状态为 pending 值为 undefined`

```js
const pro1 = new Promise((resolve, reject)=>{

});
console.log(pro1);

const pro2 = new MyPromise((resolve, reject)=>{

});
console.log(pro2);
```

![20210427202830](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427202830.png)

- [x] `执行 resolve 后 变为 resolved 状态`

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
});
console.log(pro1);

const pro2 = new MyPromise((resolve, reject) => {
    resolve(2);
});
console.log(pro2);
```

![20210427202841](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427202841.png)

- [x] `执行 reject 后 变为 rejected 状态`

```js
const pro1 = new Promise((resolve, reject) => {
    reject(1);
});
console.log(pro1);

const pro2 = new MyPromise((resolve, reject) => {
    reject(2);
});
console.log(pro2);
```

![20210427202850](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427202850.png)

- [x] `若 executor 运行时抛出错误 变为 rejected 状态`

```js
const pro1 = new Promise((resolve, reject) => {
    throw Error(1);
});
console.log(pro1);

const pro2 = new MyPromise((resolve, reject) => {
    throw Error(2);
});
console.log(pro2);
```

![20210427202945](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427202945.png)

- [x] `状态不可逆`

```js
const pro1 = new Promise((resolve, reject) => {
    resolve(1);
    reject(11);
});
console.log(pro1);

const pro2 = new MyPromise((resolve, reject) => {
    resolve(2);
    reject(22);
});
console.log(pro2);
```

![20210427203011](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427203011.png)

- [x] 独立封装一遍

`把 resolved 改为 fulfilled`

```js
const MyPromise = (() => {
    const PENDING = 'pending'; // pending 状态
    const FULFILLED = 'fulfilled'; // fulfilled 状态
    const REJECTED = 'rejected'; // rejected 状态

    const PromiseState = Symbol('[[PromiseState]]'); // promise 对象的当前状态
    const PromiseResult = Symbol('[[PromiseResult]]'); // promise 对象的当前状态数据
    const changeStatus = Symbol('changeStatus'); // 改变 promise 的状态

    return class { // 返回一个类表达式
        constructor(executor) {
            this[PromiseState] = PENDING;
            this[PromiseResult] = undefined;

            const resolve = (data) => {
                /* if (this[PromiseState] !== PENDING) {
                    return;
                } else {
                    this[PromiseState] = FULFILLED;
                    this[PromiseResult] = data;
                } */
                this[changeStatus](FULFILLED, data);
            }

            const reject = (err) => {
                /* if (this[PromiseState] !== PENDING) {
                    return;
                } else {
                    this[PromiseState] = REJECTED;
                    this[PromiseResult] = err;
                } */
                this[changeStatus](REJECTED, err);
            }

            try {
                executor(resolve, reject);
            } catch (err) {
                reject(err);
            }
        }

        /**
         * 改变当前 promise 的状态 (将其推向 settled 阶段)
         * @param {String} newState 新的状态
         * @param {*} newResult 新的值
         */
        [changeStatus](newState, newResult) {
            if (this[PromiseState] !== PENDING) {
                return;
            } else {
                this[PromiseState] = newState;
                this[PromiseResult] = newResult;
            }
        }
    }
})();
```

### 8.6.2 后续处理

`8.6.2 处理两个事件队列 thenables 和 catchables`

```
思考两个问题:
    1. 什么时候向事件队列中添加成员?
    2. 什么时候调用事件队列中的成员?
```

- 在调用 then 方法时 将 thenable 处理函数添加到作业队列 thenables 中
  - 仅传入一个参数
    - 若当前的 promise 对象的状态是 `resolved` 状态
      - 直接运行 thenable 处理函数
    - 若当前的 promise 对象的状态是 `pending` 状态
      - 将其 push 到 thenables 中
  - 传入了两个参数 `那么第二个参数就是 catchable 处理函数`
- 在调用 catch 方法时 将 catchable 处理函数添加到作业队列 catchables 中
  - 若当前的 promise 对象的状态是 `rejected` 状态
    - 直接运行 catchable 处理函数
  - 若当前的 promise 对象的状态是 `pending` 状态
    - 将其 push 到 catchables 中
- 什么时候执行?
  - 在状态改变的时候执行 事件队列 `thenables 或 catchables` 中的事件处理函数
- then 和 catch 中的程序 是 **异步** 执行的
  - 可以使用 setTimeout 来模拟异步的效果

```

```

- [ ] `thenables 和 catchables`

```js
const MyPromise = (() => {
    const PENDING = 'pending',
        RESOLVED = 'resolved',
        REJECTED = 'rejected',
        PromiseValue = Symbol('PromiseValue'),
        PromiseStatus = Symbol('PromiseStatus'),
        changeStatus = Symbol('changeStatus'),
        thenables = Symbol('thenables'), // thenables 事件队列
        catchables = Symbol('catchables'), // catchables 事件队列
        settleHandle = Symbol('settleHandler'); // 后续处理的通用函数

    return class {
        constructor(executor) {
            this[PromiseStatus] = PENDING;
            this[PromiseValue] = undefined;
            this[thenables] = []; // 后续处理函数的数组 处理 resolved 状态
            this[catchables] = []; // 后续处理函数的数组 处理 rejected 状态

            const resolve = data => {
                this[changeStatus](RESOLVED, data, this[thenables]); // 注意 可计算的属性名的读取方式 这里不能写成 this.thenables
            }

            const reject = reason => {
                this[changeStatus](REJECTED, reason, this[catchables]);
            }

            try {
                executor(resolve, reject);
            } catch (err) {
                reject(err);
            }
        }

        /**
         * 改变 promise 的状态
         * @param {String} newStatus 新的状态
         * @param {*} newValue 新的值
         * @param {*} queue 事件队列
         */
        [changeStatus](newStatus, newValue, queue) {
            if (this[PromiseStatus] !== PENDING) {
                return;
            } else {
                this[PromiseStatus] = newStatus;
                this[PromiseValue] = newValue;
            }

            queue.forEach(handler => {
                handler(newValue);
            });
        }

        /* then(thenable, catchable) {
            if (this[PromiseStatus] === RESOLVED) { // 当前的 promise 对象是 resolved 状态 直接调用 thenable 即可 不需要将它丢到 thenables 事件队列中
                // thenable(); // 注意: 因为 thenable 是异步调用的 我们如果直接这么写 它就是同步程序了
                setTimeout(() => { // 使用 setTimeout 来模拟一下异步效果
                    thenable();
                }, 0);
            } else { // 当前的 promise 对象是 pending 状态
                this[thenables].push(thenable);
            }
            this.catch(catchable);
        }

        catch (catchable) {
            if (this[PromiseStatus] === REJECTED) {
                setTimeout(() => {
                    catchable();
                }, 0);
            } else {
                this[catchables].push(catchable);
            }
        } */

        /**
         * 后续事件处理
         * @param {Function} handler 事件处理函数
         * @param {String} immediatelyStatus 立即执行的状态
         * @param {Array} queue 事件队列
         */
        [settleHandle](handler, immediatelyStatus, queue) {
            if (this[PromiseStatus] === immediatelyStatus) {
                setTimeout(() => {
                    handler();
                }, 0);
            } else {
                queue.push(handler);
            }
        }

        then(thenable, catchable) {
            this[settleHandle](thenable, RESOLVED, this[thenables]);
            if (catchable) {
                this.catch(catchable);
            }
        }

        catch (catchable) {
            this[settleHandle](catchable, REJECTED, this[catchables]);
        }

    }
})();
```

- [ ] `提取公共代码 减少冗余度`

```js
then(thenable, catchable) {
    if(this[promiseStatus] === RESOLVED){
        setTimeout(() => {
            thenable(this[promiseValue]);
        }, 0);
    }else{
        this.thenables.push(thenable);
    }
    if (catchable) {
        catchable(this[promiseValue]);
    }
}

catch(catchable) {
    if(this[promiseStatus] === REJECTED){
        setTimeout(() => {
            catchable(this[promiseValue]);
        }, 0);
    }else{
        this.catchables.push(catchable);
    }
}
```

`提取后`

```js
/**
 * 后续处理的通用函数
 * @param {Function} handler 事件处理函数
 * @param {String} immediatelyStatus 需要立即执行的状态
 * @param {Array} queue 事件队列
 */
[settleHandle](handler, immediatelyStatus, queue) {
    if(typeof handler !== 'function'){
        return;
    }
    if(this[promiseStatus] === immediatelyStatus){
        setTimeout(() => {
            handler(this[promiseValue]);
        }, 0);
    }else{
        queue.push(catchable);
    }
}

then(thenable, catchable) {
    this[settleHandle](thenable, RESOLVED, this.thenables);
    if (catchable) {
        catchable(this[promiseValue]);
    }
}

catch(catchable) {
    this[settleHandle](catchable, REJECTED, this.catchables);
}
```

```
感觉上 代码也没少多少 反而好像还多了一些, 不过需要掌握的是: 学会提取公共代码的能力, 仔细看看这个例子 提取前和提取后 是等效的, 主要是 观察 then() catch() 中 变 和 不变的地方, 变的地方 提取出来 作为函数的参数传入, 不变的地方 直接照抄就好
```

- [ ] 独立封装一遍

```js
const MyPromise = (() => {
    const PENDING = 'pending',
        FULFILLED = 'fulfilled',
        REJECTED = 'rejected',
        PromiseState = Symbol('[[PromiseState]]'),
        PromiseResult = Symbol('[[PromiseResult]]'),
        changeStatus = Symbol('changeStatus'),
        fulfilledList = Symbol('fulfilledList'), // thenables
        rejectedList = Symbol('rejectedList'), // catchables
        settleHandle = Symbol('settleHandle');

    return class MyPromise {
        [changeStatus](newStatus, newValue, queue) {
            if (this[PromiseState] !== PENDING) {
                return;
            } else {
                this[PromiseState] = newStatus;
                this[PromiseResult] = newValue;
            }
            queue.forEach(handler => {
                handler(this[PromiseResult]);
            });
        }

        constructor(executor) {
            this[PromiseState] = PENDING;
            this[PromiseResult] = undefined;
            this[fulfilledList] = [];
            this[rejectedList] = [];

            const resolve = (data) => {
                this[changeStatus](FULFILLED, data, this[fulfilledList]);
            }

            const reject = (err) => {
                this[changeStatus](REJECTED, err, this[rejectedList]);
            }

            try {
                executor(resolve, reject);
            } catch (err) {
                reject(err);
            }
        }

        [settleHandle](handler, immediatelyState, queue) {
            if (this[PromiseState] === immediatelyState) {
                setTimeout(() => {
                    handler(this[PromiseResult]);
                }, 0);
            } else {
                queue.push(handler);
            }
        }

        then(thenable, catchable) {
            this[settleHandle](thenable, FULFILLED, this[fulfilledList])
            if (catchable) {
                this.catch(catchable);
            }
        }

        catch (catchable) {
            this[settleHandle](catchable, REJECTED, this[rejectedList])
        }
    }
})();
```

**测试**

- [ ] 任务队列

```js
const pro1 = new Promise((resolve, reject)=>{
    setTimeout(() => {
        resolve('dahuyou');
    }, 1000);
});

pro1.then(data => {
    console.log('resolve', 1, data);
});
pro1.then(data => {
    console.log('resolve', 2, data);
});
pro1.then(data => {
    console.log('resolve', 3, data);
}, err => {
    console.log('reject', 1, err);
});
pro1.catch(err => {
    console.log('reject', 2, err);
});
pro1.catch(err => {
    console.log('reject', 3, err);
});
```

![20210420224337](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210420224337.png)

```js
const pro2 = new MyPromise((resolve, reject) => {
    setTimeout(() => {
        resolve('dahuyou');
    }, 1000);
});

pro2.then(data => {
    console.log('resolve', 1, data);
});
pro2.then(data => {
    console.log('resolve', 2, data);
});
pro2.then(data => {
    console.log('resolve', 3, data);
}, err => {
    console.log('reject', 1, err);
});
pro2.catch(err => {
    console.log('reject', 2, err);
});
pro2.catch(err => {
    console.log('reject', 3, err);
});
```

![20210420224337](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210420224337.png)

```js
const pro1 = new Promise((resolve, reject)=>{
    setTimeout(() => {
        reject('dahuyou');
    }, 1000);
});

pro1.then(data => {
    console.log('resolve', 1, data);
});
pro1.then(data => {
    console.log('resolve', 2, data);
});
pro1.then(data => {
    console.log('resolve', 3, data);
}, err => {
    console.log('reject', 1, err);
});
pro1.catch(err => {
    console.log('reject', 2, err);
});
pro1.catch(err => {
    console.log('reject', 3, err);
});
```

![20210420224547](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210420224547.png)

```js
const pro2 = new MyPromise((resolve, reject) => {
    setTimeout(() => {
        reject('dahuyou');
    }, 1000);
});

pro2.then(data => {
    console.log('resolve', 1, data);
});
pro2.then(data => {
    console.log('resolve', 2, data);
});
pro2.then(data => {
    console.log('resolve', 3, data);
}, err => {
    console.log('reject', 1, err);
});
pro2.catch(err => {
    console.log('reject', 2, err);
});
pro2.catch(err => {
    console.log('reject', 3, err);
});
```

![20210420224454](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210420224454.png)

### 8.6.3 串联Promise

- 状态变化
  - 当 当前的 promise 对象的 `then/catch` 运行完成后 返回的 promise 是 `resolved` 状态;
  - 如果在运行 `then/catch` 中的程序抛出了错误, 那么返回的 promise 对象是 `rejected` 状态;
- 传递的值
  - 上一个 promise 的 `thenable/catchable` 方法的返回值 作为下一个 promise 的 `[[promiseValue]]`
  - 特殊情况: 若返回的是 promise 对象, 那么下一个 promise 对象的 `[[promiseStatus]]` 和 `[[promiseValue]]` 都和返回的这个 promise 对象保持一致

```js
const MyPromise = (() => {
    const PENDING = 'pending',
        FULFILLED = 'fulfilled',
        REJECTED = 'rejected',
        PromiseState = Symbol('[[PromiseState]]'),
        PromiseResult = Symbol('[[PromiseResult]]'),
        changeStatus = Symbol('changeStatus'),
        fulfilledList = Symbol('fulfilledList'), // thenables
        rejectedList = Symbol('rejectedList'), // catchables
        settleHandle = Symbol('settleHandle'),
        linkPromise = Symbol('linkPromise'); // 创建串联的 Promise

    return class MyPromise {
        [changeStatus](newStatus, newValue, queue) {
            if (this[PromiseState] !== PENDING) {
                return;
            } else {
                this[PromiseState] = newStatus;
                this[PromiseResult] = newValue;
            }
            queue.forEach(handler => {
                handler(this[PromiseResult]);
            });
        }

        constructor(executor) {
            this[PromiseState] = PENDING;
            this[PromiseResult] = undefined;
            this[fulfilledList] = [];
            this[rejectedList] = [];

            const resolve = (data) => {
                this[changeStatus](FULFILLED, data, this[fulfilledList]);
            }

            const reject = (err) => {
                this[changeStatus](REJECTED, err, this[rejectedList]);
            }

            try {
                executor(resolve, reject);
            } catch (err) {
                reject(err);
            }
        }

        /* [linkPromise](thenable, catchable) { // 若 thenable函数 或者 catchable函数 是正常执行 那么返回的新的 Promise 的状态是 resolved 状态，若执行过程中抛出了错误，那么返回的新的 Promise 的状态是 rejected 状态
            return new MyPromise((resolve, reject) => {
                this[settleHandle]((data) => {
                    try {
                        const result = thenable(data); // 第一个参数这么写的目的是为了得知 thenable 在什么时候执行 ==> 这样我们就可以知道它执行的时候是 “正常执行” 还是 “报错” ==> 若是正常执行 那么我们可以接收到它的处理结果，并将处理结果保存到变量 result 中，作为返回的新的 Promise 的状态数据
                        resolve(result); // 一旦前一个 Promise 得到了一个处理结果 （也就是说 在执行 then 或 catch 的时候没报错） ==> 返回的新的 Promise 的状态立即变为 resolved
                    } catch (reason) {
                        reject(reason);
                    }
                }, FULFILLED, this[fulfilledList]);

                this[settleHandle]((err) => {
                    try {
                        const result = catchable(err);
                        resolve(result);
                    } catch (reason) {
                        reject(reason);
                    }
                }, FULFILLED, this[rejectedList]);
            });
        } */

        [linkPromise](thenable, catchable) { // 若 thenable函数 或者 catchable函数 是正常执行 那么返回的新的 Promise 的状态是 resolved 状态，若执行过程中抛出了错误，那么返回的新的 Promise 的状态是 rejected 状态
            function exec(data, handler, resolve, reject) {
                try {
                    const result = handler(data);
                    if (result instanceof MyPromise) {
                        result.then(data => {
                            resolve(data);
                        }, err => {
                            reject(err);
                        });
                    } else {
                        resolve(result);
                    }
                } catch (reason) {
                    reject(reason);
                }
            }
            return new MyPromise((resolve, reject) => {
                this[settleHandle]((data) => {
                    exec(data, thenable, resolve, reject);
                }, FULFILLED, this[fulfilledList]);

                this[settleHandle]((err) => {
                    exec(err, catchable, resolve, reject);
                }, FULFILLED, this[rejectedList]);
            });
        }

        [settleHandle](handler, immediatelyState, queue) {
            if (this[PromiseState] === immediatelyState) {
                setTimeout(() => {
                    handler(this[PromiseResult]);
                }, 0);
            } else {
                queue.push(handler);
            }
        }

        then(thenable, catchable) {
            // this[settleHandle](thenable, FULFILLED, this[fulfilledList]);
            if (catchable) {
                this.catch(catchable);
            }
            return this[linkPromise](thenable, catchable);
        }

        catch (catchable) {
            // this[settleHandle](catchable, REJECTED, this[rejectedList]);
            return this[linkPromise](undefined, catchable);
        }
    }
})();
```

```js
const MyPromise = (() => {
    const PENDING = 'pending',
        REJECTED = 'rejected',
        FULFILLED = 'fulfilled',
        PromiseState = Symbol('[[PromiseState]]'),
        PromiseResult = Symbol('[[PromiseResult]]'),
        changeState = Symbol('changeState'),
        fulfilledList = Symbol('fulfilledList'),
        rejectedList = Symbol('rejectedList'),
        settleHandle = Symbol('settleHandle'),
        linkPromise = Symbol('linkPromise');

    return class MyPromise {

        [changeState](newState, newValue, queue) {
            if (this[PromiseState] !== PENDING) {
                return;
            } else {
                this[PromiseState] = newState;
                this[PromiseResult] = newValue;
                queue.forEach(handler => {
                    handler(this[PromiseResult]);
                });
            }
        }

        constructor(executor) {
            this[PromiseState] = PENDING;
            this[PromiseResult] = undefined;
            this[fulfilledList] = [];
            this[rejectedList] = [];

            const resolve = (data) => {
                this[changeState](FULFILLED, data, this[fulfilledList]);
            }

            const reject = (err) => {
                this[changeState](REJECTED, err, this[rejectedList]);
            }

            try {
                executor(resolve, reject);
            } catch (err) {
                reject(err);
            }
        }

        [linkPromise](thenable, catchable) {
            function exec(data, handler, resolve, reject) {
                try {
                    const result = handler(data);
                    if (result instanceof MyPromise) {
                        result.then(data => {
                            resolve(data);
                        }, err => {
                            reject(err);
                        })
                    } else {
                        resolve(result);
                    }
                } catch (err) {
                    reject(err);
                }
            }
            return new MyPromise((resolve, reject) => {
                this[settleHandle](((data) => {
                    if (typeof thenable !== 'function') {
                        resolve(data);
                        return;
                    }
                    exec(data, thenable, resolve, reject);
                }), FULFILLED, this[fulfilledList]);

                this[settleHandle](((reason) => {
                    if (typeof catchable !== 'function') {
                        reject(reason);
                        return;
                    }
                    exec(reason, catchable, resolve, reject);
                }), REJECTED, this[rejectedList]);
            });
        }

        [settleHandle](handler, immediatelyState, queue) {
            if (this[PromiseState] === immediatelyState) {
                setTimeout(() => {
                    handler(this[PromiseResult]);
                }, 0);
            } else {
                queue.push(handler);
            }
        }

        then(thenable, catchable) {
            if (catchable) {
                this.catch(catchable);
            }
            return this[linkPromise](thenable, catchable);
        }

        catch (catchable) {
            return this[linkPromise](undefined, catchable);
        }
    }
})();


/* 测试 */
new MyPromise((resolve, reject) => {
    setTimeout(() => {
        resolve(1);
    }, 1000);
}).catch(err => {
    console.log(err);
}).then(data => {
    console.log(data);
});


new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(1);
    }, 1000);
}).catch(err => {
    console.log(err);
}).then(data => {
    console.log(data);
});


new MyPromise((resolve, reject) => {
    setTimeout(() => {
        reject(1);
    }, 1000);
}).then(data => {
    console.log(data);
}).catch(err => {
    console.log(err);
});


new Promise((resolve, reject) => {
    setTimeout(() => {
        resolve(1);
    }, 1000);
}).then(data => {
    console.log(data);
}).catch(err => {
    console.log(err);
});

const pro = new MyPromise((resolve, reject) => {
    resolve(1);
});

pro.then(data => {
    console.log(data);
    return 'dahuyou';
}).then(data => {
    console.log(data);
})

ajax({
    url: './data/students.json?name=李华',
}).then(stus => {
    for (let i = 0; i < stus.length; i++) {
        const stu = stus[i];
        if (stu.name === '李华') {
            const cid = stu.classId; // 获取到班级id
            console.log(`获取到李华所在的班级id: ${cid}`);
            return cid;
        }
    }
}).then(cid => {
    return ajax({
        url: './data/classes.json?classId=' + cid,
    }).then(cls => {
        for (let i = 0; i < cls.length; i++) {
            const cl = cls[i];
            if (cl.id === cid) {
                const tid = cl.teacherId;
                console.log(`获取到班级id为: ${cid} 的老师id: ${tid}`);
                return tid;
            }
        }
    });
}).then(tid => {
    return ajax({
        url: './data/teachers.json?teacherId=' + tid,
    }).then(ts => {
        for (let i = 0; i < ts.length; i++) {
            const t = ts[i];
            if (t.id === tid) {
                console.log(`获取到id为: ${tid} 的老师信息`, t);
                return t;
            }
        }
    });
}).then(t => {
    console.log('此时已经获取到了李华的老师信息, 下面可以对其进行相关操作');
    console.log(t);
});
```

### 8.6.4 其他API

```
static all
static race
static resolve
static reject
```

```js
const MyPromise = (() => {
    const PENDING = 'pending',
        REJECTED = 'rejected',
        FULFILLED = 'fulfilled',
        PromiseState = Symbol('[[PromiseState]]'),
        PromiseResult = Symbol('[[PromiseResult]]'),
        changeState = Symbol('changeState'),
        fulfilledList = Symbol('fulfilledList'),
        rejectedList = Symbol('rejectedList'),
        settleHandle = Symbol('settleHandle'),
        linkPromise = Symbol('linkPromise');

    return class MyPromise {

        [changeState](newState, newValue, queue) {
            if (this[PromiseState] !== PENDING) {
                return;
            } else {
                this[PromiseState] = newState;
                this[PromiseResult] = newValue;
                queue.forEach(handler => {
                    handler(this[PromiseResult]);
                });
            }
        }

        constructor(executor) {
            this[PromiseState] = PENDING;
            this[PromiseResult] = undefined;
            this[fulfilledList] = [];
            this[rejectedList] = [];

            const resolve = (data) => {
                this[changeState](FULFILLED, data, this[fulfilledList]);
            }

            const reject = (err) => {
                this[changeState](REJECTED, err, this[rejectedList]);
            }

            try {
                executor(resolve, reject);
            } catch (err) {
                reject(err);
            }
        }

        [linkPromise](thenable, catchable) {
            function exec(data, handler, resolve, reject) {
                try {
                    const result = handler(data);
                    if (result instanceof MyPromise) {
                        result.then(data => {
                            resolve(data);
                        }, err => {
                            reject(err);
                        })
                    } else {
                        resolve(result);
                    }
                } catch (err) {
                    reject(err);
                }
            }
            return new MyPromise((resolve, reject) => {
                this[settleHandle](((data) => {
                    if (typeof thenable !== 'function') {
                        resolve(data);
                        return;
                    }
                    exec(data, thenable, resolve, reject);
                }), FULFILLED, this[fulfilledList]);

                this[settleHandle](((reason) => {
                    if (typeof catchable !== 'function') {
                        reject(reason);
                        return;
                    }
                    exec(reason, catchable, resolve, reject);
                }), REJECTED, this[rejectedList]);
            });
        }

        [settleHandle](handler, immediatelyState, queue) {
            if (this[PromiseState] === immediatelyState) {
                setTimeout(() => {
                    handler(this[PromiseResult]);
                }, 0);
            } else {
                queue.push(handler);
            }
        }

        then(thenable, catchable) {
            /* if (catchable) {
                this.catch(catchable);
            } */
            return this[linkPromise](thenable, catchable);
        }

        catch (catchable) {
            return this[linkPromise](undefined, catchable);
        }

        static all(proms) {
            return new MyPromise((resolve, reject) => {
                const results = proms.map(p => {
                    const obj = {
                        result: undefined,
                        isFulfilled: false
                    }
                    p.then(data => {
                        obj.result = data;
                        obj.isFulfilled = true;
                        const unFulfilled = results.filter(r => !r.isFulfilled);
                        if (unFulfilled.length === 0) { // 当未完成的 Promise 的个数为 0 的时候，即：所有的Promise都完成了
                            resolve(results.map(r => r.result)); // 则将所有的 Promise 的状态数据映射为一个数组 作为 resolved 状态的数据传入
                        }
                    }, reason => { // 一旦有失败的 新返回的 Promise 直接变为 rejected 状态
                        reject(reason);
                    });
                    return obj;
                });
            })
        }

        static race(proms) {
            return new MyPromise((resolve, reject) => {
                proms.forEach(p => {
                    p.then(data => { // 一旦有一个 Promsie 的状态发生改变，那么返回的Promise的状态也就会随之发生改变
                        resolve(data);
                    }, err => {
                        reject(err);
                    });
                })
            });
        }

        static resolve(data) {
            if (data instanceof MyPromise) { // [特殊情况] 若 resolve 传入的参数是一个 Promise 对象 那么直接将该 Promise 对象返回即可
                return data;
            } else {
                return new MyPromise((resolve, reject) => {
                    resolve(data);
                });
            }
        }

        static reject(reason) {
            return new MyPromise((resolve, reject) => {
                reject(reason);
            });
        }
    }
})();
```

### 8.6.5 补充

```
两处小 bug
```
## 8.7 async和await

```
async 和 await 实际上是俩语法糖
在学习它们的过程中 多写几遍它们的等效写法 更有助于掌握它们实际表示的含义和作用
```

async 和 await 是 ES2016 新增两个关键字，它们借鉴了 ES2015 中生成器在实际开发中的应用，目的是简化 Promise api 的使用，并非是替代 Promise。

**async**

目的是简化在函数的返回值中对Promise的创建

async 用于修饰函数（无论是函数字面量还是函数表达式），放置在函数最开始的位置，被修饰函数的返回结果一定是 Promise 对象。

```js
async function test(){
    console.log(1);
    return 2;
}
```

`等效写法`

```js
function test(){
    return new Promise((resolve, reject)=>{
        console.log(1);
        resolve(2);
    })
}
```

```
被 async 修饰的函数 必定返回 Promise 对象

若要执行 Promise 对象中的 resolve(参数); 那么就直接 return 参数;

    async function test() {
        return 参数;
    }
    等价于
    function test() {
        return new Promise((resolve, reject) => {
            resolve(参数);
        });
    }

若要执行 Promise 对象中的 reject(参数); 那么就直接 throw 参数;

    async function test() {
        throw 参数;
    }
    等价于
    function test() {
        return new Promise((resolve, reject) => {
            reject(参数);
        });
    }
```

- [x] demo

`特殊情况: 返回 promise 对象`

```js
async function test() {
    console.log('dahuyou');
    return new Promise((resolve, reject) => {
        resolve(1);
    });
}

const a = test();

console.log(a);
```

![20210427191918](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427191918.png)

```
如果 被 async关键字 修饰的函数中 返回的是一个 promise 对象 那么就直接返回该 promise 对象 (也就是说 此时写/不写 async 关键字来修饰该函数 效果都是一样的)

    async function test() {
        return new Promise((resolve, reject) => {
            resolve(参数);
        });
    }

    等价于

    function test() {
        return new Promise((resolve, reject) => {
            resolve(参数);
        });
    }
```

- [x] demo

```js
function test() {
    console.log('dahuyou');
    return new Promise((resolve, reject) => {
        resolve(1);
    });
}

const a = test();

console.log(a);
```

![20210427191933](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210427191933.png)

```
是否使用 async 关键字来修饰 貌似还是有点区别的 就是返回的 promise 对象的初始状态 是不同的... (原因不详, 先跳过... )
```

- [x] demo

`[特殊情况] 注意 async 修饰的函数的返回值的书写位置`

```js
async function biaobai(god) {
    console.log(`邓哥向女生【${god}】发出了表白短信`);
    setTimeout(() => {
        if (Math.random() < 0.5) {
            return true;
        } else {
            return false;
        }
    }, 3000);
}
```

```
[注] 上面这样的写法是错误的, 因为setTimeout 也是一个函数, 我们若要返回(return), 那么得在 biaobai 函数中返回, 而不能在其他函数中返回, 这个案例就是在 biaobai 函数内部的其他函数(setTimeout)中返回, 并不是biaobai函数的返回值
```

```js
// 这种情况还是老老实实的不要使用 async 提供的语法糖来实现函数内部返回 Promise, 直接写等效的代码就好
function biaobai(god) {
    console.log(`邓哥向女生【${god}】发出了表白短信`);
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            if (Math.random() < 0.5) {
                resolve(true);
            } else {
                resolve(false);
            }
        }, 3000);
    });
}
```

**await**

await关键字只能出现在async函数中！！！！

await用在某个表达式之前，如果表达式是一个Promise，则得到的是thenable中的状态数据。`得到的是该 Promise 的处理结果, 该`

```
思考: 为什么 await 关键字 只能出现在 被 async 关键字修饰的函数中?
视频: 12min ~ 16min 有讲到, 但是没理解为什么... 目前的理解是:
    1. 从 "等待" 的角度 ==> 因为 await 起到了一个等待处理结果的功能, 如果它出现在了普通函数中, 那么会出问题, 因为普通函数的调用 瞬间就执行完了, 如果执行到 await 修饰的语句时, 还要等, 那显然是矛盾的; 但是, 如果 await 出现在了 async 修饰的函数中, 因为 async 修饰的函数返回的是一个新的 Promise 对象, 被修饰的函数的所有代码, 都是异步的, 都会被丢到 Promise 构造函数的参数方法中执行, 而异步代码, 等, 就合情合理了;
    2. 从返回值的角度 ==> 普通函数的返回值, 就是很正常的返回值, 而 await 修饰的 异步程序之后的 return 语句, 相当于 resolve 语句, 因为 await 之所以能够起到等待的作用, 其实就是它把后续的代码都放到了 then 方法中, 而 then 方法中的代码能够执行的前提是, 被 await 修饰的那个 Promise 对象被推向了 settled 阶段, 但是 return 将被识别为 resolve, 因为如果还是 return 的话, 那么就相当于是返回被 await 修饰的那个 Promise 的结果数据了, 而不是 async 修饰的函数所返回的结果数据;
    ... 应该是理解错了 ... 反正就是强行解释一波 ... 实在想不出来为何 await 只能用在 async 修饰的函数中 (学过node之后, 这句话貌似就不成立了 在网上看了一下 好像是可以举出反例的)
    PS: 提供一个渠道: 在学完 Generator 之后, 可以尝试使用 Generator 来仿造 async 和 await 的效果, 来手写一下 async 和 await (前提: 先能够熟练的使用 async 和 await 再说)
```

```js
async function test1(){
    console.log(1);
    return 2;
}

async function test2(){
    const result = await test1();
    console.log(result);
}

test2();
```

`等效写法`

```js
function test1(){
    return new Promise((resolve, reject)=>{
        console.log(1);
        resolve(2);
    })
}

function test2(){
    return new Promise((resolve, reject)=>{
        test1().then(data => {
            const result = data;
            console.log(result);
            resolve();
        })
    })
}

test2();
```

```
可以这么理解: await 修饰的 promise 的后续的语句 都在 该 promise 的 then 里面
比如该案例中 await 修饰的 test1(), 它后面的所有程序 都在 test1().then(...) 的 then 里面
```

- [x] demo

```js
new Promise((resolve, reject) => {
    console.log(1);
    resolve(2);
}).then(result => {
    console.log(result);
});
```

![20210421154531](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210421154531.png)

`等效写法`

```js
async function test1() {
    console.log(1);
    return 2;
}

async function test2() {
    const result = await test1();
    console.log(result);
}

test2();
```

> 回看 8.1 中的使用 async 和 await 关键字来实现获取老师信息的demo

- [x] demo

`async 也可以用来修饰立即执行函数`

```js
// (async function() { // 像是这样写成函数表达式的形式 也 okk
(async () => {
    const cid = await ajax({ // 获取所有的学生信息
        url: './data/students.json'
    }).then(stus => {
        for (let i = 0; i < stus.length; i++) {
            const stu = stus[i];
            if (stu.name === '李华') {
                const cid = stu.classId; // 获取到班级id
                console.log(`获取到李华所在的班级id: ${cid}`);
                return cid;
            }
        }
    });
    const tid = await ajax({
        url: './data/classes.json'
    }).then(cls => {
        for (let i = 0; i < cls.length; i++) {
            const cl = cls[i];
            if (cl.id === cid) {
                const tid = cl.teacherId;
                console.log(`获取到班级id为: ${cid} 的老师id: ${tid}`);
                return tid;
            }
        }
    });
    const t = await ajax({
        url: './data/teachers.json'
    }).then(ts => {
        for (let i = 0; i < ts.length; i++) {
            const t = ts[i];
            if (t.id === tid) {
                console.log(`获取到id为: ${tid} 的老师信息`, t);
                return t;
            }
        }
    });
    console.log('此时已经获取到了李华的老师信息, 下面可以对其进行相关操作');
    console.log(t);
})();
```

![20210511205831](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210511205831.png)

- [x] demo

`将 async 和 await 的语法糖转化为常规的 Promise 写法`

```js
(async () => {
    const stus = await ajax({
        url: './data/students.json'
    });
    let cid = null;
    for (let i = 0; i < stus.length; i++) {
        const stu = stus[i];
        if (stu.name === '李华') {
            cid = stu.classId;
        }
    }
    const cls = await ajax({
        url: './data/classes.json'
    });
    let tid = null;
    for (let i = 0; i < cls.length; i++) {
        const cl = cls[i];
        if (cl.id === cid) {
            tid = cl.teacherId;
        }
    }
    const ts = await ajax({
        url: './data/teachers.json'
    });
    let teacher = null;
    for (let i = 0; i < ts.length; i++) {
        const t = ts[i];
        if (t.id === tid) {
            teacher = t;
        }
    }
    console.log(teacher);
})();

/* 等价写法 */

(() => {
    return new Promise((resolve, reject) => {
        ajax({
            url: './data/students.json'
        }).then(data => {
            const stus = data;
            let cid = null;
            for (let i = 0; i < stus.length; i++) {
                const stu = stus[i];
                if (stu.name === '李华') {
                    cid = stu.classId;
                }
            }
            ajax({
                url: './data/classes.json'
            }).then(data => {
                const cls = data;
                let tid = null;
                for (let i = 0; i < cls.length; i++) {
                    const cl = cls[i];
                    if (cl.id === cid) {
                        tid = cl.teacherId;
                    }
                }
                ajax({
                    url: './data/teachers.json'
                }).then(data => {
                    const ts = data;
                    let teacher = null;
                    for (let i = 0; i < ts.length; i++) {
                        const t = ts[i];
                        if (t.id === tid) {
                            teacher = t;
                        }
                    }
                    console.log(teacher);
                });
            });
        });
    });
})();
```

![20210512000037](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210512000037.png)

- [x] demo

```js
function biaoBai(god) {
    return new Promise((resolve, reject) => {
        console.log(`邓哥向${god}发出了表白短信`);
        setTimeout(() => {
            if (Math.random() < 0.1) {
                resolve(true); // 女神同意了
            } else {
                resolve(false); // 女神拒绝了
            }
        }, 0);
    });
}

const godsArr = ['女神1', '女神2', '女神3', '女神4', '女神5'];
let pro;

for (let i = 0; i < godsArr.length; i++) {
    const god = godsArr[i];
    if (i === 0) {
        pro = biaoBai(god);
    }
    pro = pro.then(result => {
        if (result === true) {
            console.log(`${god}同意了 停止表白`);
            return;
        } else if (result === undefined) { // 已经有女神同意了 接下来啥也不做
            return;
        } else {
            if (god !== godsArr[godsArr.length - 1]) {
                console.log(`${god}拒绝了 继续向${godsArr[i + 1]}表白`);
                return biaoBai(godsArr[i + 1]);
            } else {
                console.log(`${god}拒绝了 全都拒绝了`);
            }
        }
    });
}
```

- [x] demo

`使用 async 和 await 来实现`

```js
async function biaoBaiAll() {
    const godsArr = ['女神1', '女神2', '女神3', '女神4', '女神5'];
    for (let i = 0; i < godsArr.length; i++) {
        const god = godsArr[i];
        const result = await biaoBai(god); // 当前循环等待的 promise 没有 resolve ==> 下一次循环不运行
        if (result === true) {
            console.log(`${god}同意了 停止表白`);
            break;
        } else {
            if (god !== godsArr[godsArr.length - 1]) {
                console.log(`${god}拒绝了 继续向${godsArr[i + 1]}表白`);
            } else {
                console.log(`${god}拒绝了 全都拒绝了`);
            }
        }
    }
}

biaoBaiAll();
```

```
在循环中使用 await 关键字的注意点 ==> 当前循环等待的 promise 没有 resolve ==> 下一次循环不运行 ==> 所以我们不用再写 串联的 promise 来实现了
```

如果await的表达式不是Promise，则会将其使用Promise.resolve包装后按照规则运行

- [x] demo

`await 后面跟的不是 promise 的情况`

```js
async function test() {
    const result = await 1;
    console.log(result);
}

test();

console.log(123);
```

`等效`

```js
function test() {
    return new Promise((resolve, reject) => {
        Promise.resolve(1).then(data => {
            const result = data;
            console.log(result);
        })
    });
}

test();

console.log(123);
```

![20210421164052](https://cdn.jsdelivr.net/gh/123taojiale/dahuyou_picture@main/blogs/20210421164052.png)

```
如果await的表达式不是Promise，则会将其使用Promise.resolve包装后按照规则运行
```

- [x] demo

`如何在 async 修饰的函数中 将返回的 promise 对象推向 rejected 状态`

```js
async function getPromise() {
    if (Math.random() < 0.5) {
        return 1;
    } else {
        throw 2;
    }
}

async function test() {
    /* getPromise().then(data => {
        const result = data;
        console.log("正常状态", result)
    }, err => {
        console.log("错误状态", err);
    }) */
    // 等效
    try {
        const result = await getPromise();
        console.log("正常状态", result)
    } catch (err) {
        console.log("错误状态", err);
    }
}

test();
```

当 await 修饰的 promise 在推向 settled 阶段的过程中出现了错误, 该如何处理?

- [x] demo

```js
async function myFunction() {
    try {
        await somethingThatReturnAPromise();
    } catch (err) {
        console.log(err);
    }
}
```

```
由于 await 修饰的 promise 也有可能会出错 (也就是会推向 rejected 状态) 所以一般会将它写在 try-catch 里面
```

- [x] demo

`使用 promise.catch api 来替代 try-catch`

```js
async function myFunction() {
    await somethingThatReturnAPromise().catch(function (err) {
        console.log(err);
    });
}
```

- [x] demo

`改造计时器函数`

```js
function delay(duration) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, duration);
    })
}

async function biaobai(god) {
    console.log(`邓哥向${god}发出了表白短信`);
    await delay(500);
    return Math.random() < 0.3;
}
```

```
注意: 这个 delay 只能在被 async 修饰的函数中使用 否则无效
```

- [x] demo

```js
function delay(duration) {
    return new Promise((resolve, reject) => {
        setTimeout(() => {
            resolve();
        }, duration);
    })
}

function test() {
    delay(1000);
    console.log('dahuyou'); // 并不会等 1s 后输出 dahuyou
}

test();
```

