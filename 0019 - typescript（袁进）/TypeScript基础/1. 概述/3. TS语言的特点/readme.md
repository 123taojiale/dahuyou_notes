# 3. TS语言的特点

29:43

## 00:00:10

本节介绍 TS 的一些特点，并体验一下它是如何解决我们之前提到的问题的。

## 00:00:35

这是袁老给的，对于 ts 的定义。

这句话里边信息量很多，别看就几个字。

## 00:00:35

先把袁老对 TS 的理解写出来，下面再对其解释说明。

## 00:02:02

ts 和 es 之间的关系

## 00:03:50

外边蓝色的这一层，其实就是 ts 相对于 es 所多出的内容，这一部分，其实就是 ts 给我们提供的「类型系统」

而类型系统的作用，就是为我们提供类型检查

我们接下来学习的重点，其实也就是这一块类型系统。即：TS 中相对于 ES 而言，不同的地方。

## 00:03:51

蓝色部分，TS 中新增的内容，其实就是 TS 的类型系统。

也正是我们所要学习的重点内容。

## 00:04:36

理解什么叫「超级」

## 00:04:48

理解 TS 相对于我们之前所学习的 JS，新增了些啥？

其实就是一个类型系统，并没有增强什么功能性的玩意儿。

也就说明，我们使用 TS，并不能实现某些使用 JS 无法实现的功能。

## 00:06:01

「超集」、「类型系统」

这两点是 TS 中最为核心的两个特点

下面介绍什么是「可选的」

## 00:08:35

这是上节课的代码， 下面我们将 .js 改为 .ts

查看一下效果

## 00:08:51

当我们将 js 文件改为 ts 文件后，会发现 - 一些及其低级的错误，立刻就有报错提示了

这也正是我们所希望看到的

## 00:09:22

此时提示：myname 变量的数据类型，有可能是 string 或者 number

如果它的类型是 number 的话，那么是不存在属性 split 的

也就是预防我们将一个不确定的类型，视作一个确定的类型来使用

## 00:09:40

直接将鼠标悬停在对应的函数上（该函数的返回值是赋值给 myname 变量的）

上一步我们说到：myname 的值可能是 number、string

这是由当前函数 getUserName 的返回值所决定的

## 00:10:01

此时我们需要做的事情很简单

既然 ts 认为我们在使用一个不确定的类型，那么我们只要限定一下它的类型就好了

通过 typeof 关键字，就可以做到这一点

当代码执行到 if 语句块里边之后，就说明 myname 的数据类型一定是 string 类型了

此时 split 下边就不再有错误提示了

## 00:10:25

同样的，对于这种 API 调用出错的低级错误，TS 也能够非常智能地识别出来

## 00:11:23

所有能写 JS 的地方，都能写 TS

## 00:12:16

|「静态的」

## 00:12:54

getUserName 函数，返回的数据的数据类型，要么是 string 要么是 number

## 00:13:10

.ts 文件中的代码，我们是没法直接执行的，需要进行编译之后才能执行

## 00:13:13

当我们在 node 环境中，直接去执行 index.ts 文件中的代码时，控制台会抛出错误

## 00:13:52

之前在学习 babel 的时候，得知它是用来做语法转换的

比如：将 es6 语法转为等效的 es5 语法

## 00:14:23

在 TS 中，我们可以使用 tsc 将我们写的 ts 代码给转换为 js 代码

tsc：它是 ts 的编译器

## 00:14:50

我们前边学习过 babel，它是用来做代码转换的，用 babel 可以将我们高版本的 es 代码转为低版本的 es 代码，已达到更好地兼容性；

其实 ts 也是可以转为 js 的，我们得使用 tsc 来实现。

tsc 和 babel

tsc 和 babel 的功能类似，都是用来做代码转换的，只不过 tsc 的作用是将 ts 转为 js

tsc 全称 ts compiler 也就是 ts 编译器

## 00:15:10

tsc index.ts

将 index.ts 文件中的 ts 代码转换为 js 代码，会新生成一个 index.js 文件，这个文件中的内容就是转换后的 js 代码

补充：有关 tsc 的更多内容，后边课程会介绍到的，现在袁老只是做一个演示，让我们看看效果。

## 00:16:40

ts 是静态的

这一特点说明了以下信息：
1. TS 的类型检查比 JS 要早，JS 没有编译阶段，JS 中如果出现了类型错误，需要等到代码运行的时候才能发现，TS 有编译阶段，如果出现类型错误，那么在编译阶段就会抛出错误，而不会等到代码执行时才抛出
2. TS 的代码通过 tsc 编译为 JS 代码，如果编译过程没有发生错误，并且正常生成了 JS 代码，那么说明类型检查通过了

## 00:17:22

理解「静态」表示的是什么含义

就是我们所写的 ts 代码，它为我们提供的类型检查，是在编译的时候

在最终的编译结果中，它们是不参与运行的

最终运行的，是转换后的 js 代码，而非 ts 代码

## 00:18:04

因为最终运行的并非 ts，而是由 ts 编译而来的 js 代码，如果代码都开始运行了，那么就没有 ts 什么事儿了。

## 00:18:16

前边介绍的，都是本节课的重点，尽可能地去理解、掌握

下面开始介绍  TS 的一些常识

## 00:18:40

TS 是微软发布的

## 00:19:49

TS 的作者

## 00:21:27

TS 是开源的项目

我们在 github 上可以找到它的源代码

并且它还是拥抱 es 标准的

也就是说，如果后边 es 的语法有了新的变化，ts 的语法和新的 es 语法不匹配了。那么 ts 将修改旧的语法，来适应新的 es 语法，拥抱 es 标准。

如果了解过浏览器大战的历史，会发现这一点对于微软来说，是非常难得的。微软 - 行业老大哥

## 00:21:56

TS 是开源的，并且还是拥抱 ES 标准的，也就是说，当 ES 更新之后，TS 也会随之更新，并且会兼容最新的 ES 特性。

这句话其实就是在说明：即便 ES 更新了，新增了一些特性，这些特性在 TS 中没法用，TS 也会尽快地完成更新，将相关的新特性都包含进去。

🤔 知道这个对我们有啥帮助么？
这说明，我们在 TS 中，想要使用最新的 ES 特性，基本上都是没问题的，都是支持的。

小结：TS 始终都会是 ES 的超集

## 00:22:05

授课时的版本是 3.4

## 00:22:10

Anders Hejlsberg
TS 的作者

## 00:23:35

英文过关的同学，推荐直接看英文的

中文文档中，有些地方可能会出现翻译错误的情况

## 00:28:52

面向对象开发

它已经有 20 来年的历史了，这种开发方式，在很多场景（比如“权限管理”）中，早已形成了很多最佳实践，针对这些场景，它都能够提供最佳的解决方案。

虽然说 JS 也支持面向对象的开发方式，但是由于 JS 没有类型检查系统，使用起来成本太高，体验太差。

出现了 TS 之后，补上了 JS 在类型检查这一块的短板，所以也就间接地增强了 JS 面向对象的开发方式。

