# 4-1. ES6模块化简介

ECMA组织参考了众多社区模块化标准，终于在2015年，随着ES6发布，推出了官方的模块化标准，后称为ES6模块化。

ES6模块化具有以下的特点：

1. 使用依赖**预声明**的方式导入模块
   - 依赖延迟声明
      - 优点：某些时候可以提高效率。（可以选择性引入指定模块，仅在指定条件下引入相关的模块，当条件不满足时，不引入。）
      - 缺点：无法在一开始确定模块依赖关系。（模块之间的依赖关系比较模糊。）
   - 依赖预声明
      - 优点：在一开始可以确定模块依赖关系
      - 缺点：某些时候效率较低（后续课程 “构建工具” 会介绍解决办法。）
2. 灵活的多种导入导出方式。（这一点，比 CommonJS 更灵活。）
3. 规范的路径表示法：所有路径必须以 `./` 或 `../` 开头

问：路径如果不以 ./ 或 ../ 开头，导入语句不放在程序最开始的位置，会发现都没有报错，是啥原因呢？

答：因为浏览器的容错机制，可以理解为它帮我们加上了 `./` 或 `../`。（但是，咋们还是得按照规范来写更好。）

- 依赖延迟声明 VS 依赖预声明

依赖延迟声明导入模块，可以选择性引入模块，仅引入需要的模块即可，不需要的模块可以不引入，但是依赖预声明导入模块不行。

这种方式可以避免不必要的模块的引入，通常，效率会相对较高一些。

```js
if(xxx) {
    require('a');
} else {
    require('b');
}
```

AMD 开始就是使用依赖预声明的方式来导入模块的，这里就先以 AMD 来举例说明。

依赖预声明导入模块 可以一开始就确定模块的依赖关系，相对于 使用延迟声明导入模块 的方式而言，依赖关系更加直观。

这种方式更加有助于后期的维护，并且更加直观，方便阅读。

```js
define(['a', 'b'], function(a, b) { // 依赖 a 模块 和 b 模块
    // xxx
    return xxx;
});
```

ES6 采用依赖预声明的方式来引入模块，也许就是考虑到：还有其他途径来解决效率相对较低的问题。但是从程序的可读性和可维护性角度来看的话，也许不那么容易解决。并且很多语言（比如：C#、Java），它们在实现模块化的时候，采用的都是预声明的方式。所以，综合考虑后，选择的是 依赖预声明的方式来导入模块。

ES6 模块化 和 CommonJS 模块化，是我们学习后期的 WebPack 课程的基础。

## 小结

- ES6 采用依赖预声明；CommonJS 采用依赖延迟声明。
- ES6 的模块导入导出的方式，比 CommonJS 更加灵活。
- 模块路径书写时，都要以 `./` 或 `../` 开头。